Firmware
========

The firmware is OOP and is entirely written in C++. Both processors the core ARM MCU and the ESP8266 WIFI are developed as part of the same framework integrating seemingly by using a set of bridge libraries that provide a unifies the RPC architecture. This software was partially developed by IAAC as part of the Making Sense project under the European Community's H2020 Programme Grant Agreement No. 688620. 

Firmware updates are done via the micro USB port using the Platform IO software available for Linux, Mac and Windows. 

## Architecture

```
## SAM

Definitions
	Pins
	Sensors

Commands
Sensors
ReadLight
ReadSound
SckAux
SckBase
SckButton
SckCharger
SckLed
SckUrban

## Shared

Definitions
	Shared
	Config


## ESP
SckESP
```

## Data management
The board is capable of storing the recorded data offline on its internal dedicated flash memory of 8MB and later publish this over Wi-Fi connectivity provided by an Espressif ESP8266. Data is published using MQTT messages to the Smart Citizen Platform. NTP is used for syncing the built-in RTC. For long term offline storage, the board provides a standard microSD socket where card in the orders of GB can be employed. That ensures extended periods of data in the order of decades can be stored.

## Configuration
The board firmware is fully customizable without requiring any changes to the core software. That includes enabling or disabling sensors, the sampling frequency of the sensors or the operation mode. There different configuration options: via the Serial Shell available when the board is connected over USB, editing the config.txt file when using a microSD card or over the network using MQTT messages (this mode is currently under development)

## Storage

### Devices
* [Flash memory (8mb).](https://hackmd.io/CYRmGYFMGMCYE4C0IAM8BsiAsKaPgBwoDsiB6AhpJBbAEYCssk6QA===?both#SPI-Flash-Memory-S25FL064L)
    SPIFFS file system seems to be a good option.
* [SDcard](https://hackmd.io/CYRmGYFMGMCYE4C0IAM8BsiAsKaPgBwoDsiB6AhpJBbAEYCssk6QA===?both#SDcard)
    Sdfat is the library we are using to manage sdcard filesystem.

### Support functions
* Detects when a card is inserted or removed, this function is called from an interrupt in _CD_MMC_ pin. So we can react to card events.
`bool sdDetect()`
* Selects and starts the device.
`bool sdBegin()`
`bool flashBegin()`
* Open a file (it takes care on selecting and starting the right device)
`File sdOpen(sckFile wichFile, uint8_t oflag)`
`File flashOpen(sckFile wichFile, uint8_t oflag)`


```=clike
struct SckFile {
    char name[13]; 
    File file;
}

uint8_t	oflag 
O_READ - Open for reading.
O_APPEND - If set, the file offset shall be set to the end of the file prior to each write.
O_CREAT - We need to delete previous file before creating the new.
```

### Stored information

#### Configuration file **CONFIG.TXT**

If this file doesn't exist it is generated by the kit with the factory defaults and after that it can be modified by both the user and the kit. `SckBase::resetConfigFile();`

If the modification comes from the kit (sound, platform, etc) it should be saved to the flash and then to the SD.

When the file is read from the SD if it is valid and different from the flash version the flash version should be updated. There is a problem in this approach: if the user insert and old scard with an old config without erasing it he can mess an newly configured kit. To solve this there is the possibility of having a first entry in the config file that is called something like _user_modified_ and the user should modify this so the new config is loaded. If this flag is not true the sdcard config would be overwritten with the one in the flash.

:::danger
This file will be restored to default values in a _factory reset event._
:::

#### Readings file **POST.CSV**

This file is generated and updated by the kit.

When a SD is detected this file will be synced with the flash version as the correct one. For this to work we need a fast way to compare the files. We need to test if this is doable in terms of speed. Maybe only do this when it is requested via a command or user input.

There should be a way to know if a post has been uploaded to the platform, so when the kit doesn't have a wifi connection it saves the readings and publish them as soon as a network connection is available.

:::danger
This file will be erased in a _factory reset event._
:::

#### Debug log file **DEBUG.CSV**

The debug file is generated and updated by the kit, only if the debug mode is enabled on the configuration.

When the debug mode is enabled the verbosity level of this file is defined by the outlevel (_normal, verbose or silent_).

:::danger
This file will be erased in a _factory reset event._
:::


