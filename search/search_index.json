{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"iSCAPE Sensors Documentation Link Introduction Link The iSCAPE sensor platform builds on the legacy of previous Smart Citizen generations to develop a new set of tools especially aimed at providing meaningful environmental data insights on a low budget. That means this report documents new components, developed specifically for the project, but frames them inside the Smart Citizen ecosystem. We believe building modular and reusable hardware is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. Environmental sensors play a critical role in the ISCAPE project the primary goals being: Engage local communities at the Living Labs to deploy and learn about sensors as a novel way to learn about their environment, in particular cities air pollution issues. Provide a sensor infrastructure to enable the different sites to monitor the performance of their interventions. To support this approach, we needed to accomplish three key requirements: Modularity: The sensor hardware operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes. Open design and documentation: All the components developed are released on open source license to foster the collaboration between different the stakeholders. That especially aims at involving the Living Labs on the design of new sensing strategies and technologies. Easy to use: The technology needs to be accessible to ensure users engagement, especially for those sensors targeting at citizens, but also to ensure the technology development is ready to be exploded commercially after the project. The following approach led the project to development of two sensor solutions: The Citizen Kit and the Living Lab Stations . The following website contains the full documentation of the software and hardware sensor platform developed for the project. It is aimed at any project stakeholder to learn how to use the different components and also to contribute on its future development. Sections Link Main: Contains the Citizen Kit and Living Lab Stations documentation to help participants to use them. Components: Contains all the documentation on the different hardware sensor modules with detailed insights on the sensors behaviour and calibration. Sensor Analysis Framework: Contains all the documentation on the data post processing framework to obtain insights from the data calibrated by the sensors. Sensor Platform: Contains all the documentation on the sensors web platform were data is collected, stored and vizualized. Guides Link The documentation contains multiple guides as step-by-step tutorials to perform important tasks as installing a sensor type or uploadig the software on the sensors. Example guides Installing the Living Labs Station Installing the Citizen Kit Onboarding Sensors Uploading CSV Data Update the Firmware Edit the Firmware Open Source Link We're against black boxes! The entire project it is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Home"},{"location":"#iscape-sensors-documentation","text":"","title":"iSCAPE Sensors Documentation"},{"location":"#introduction","text":"The iSCAPE sensor platform builds on the legacy of previous Smart Citizen generations to develop a new set of tools especially aimed at providing meaningful environmental data insights on a low budget. That means this report documents new components, developed specifically for the project, but frames them inside the Smart Citizen ecosystem. We believe building modular and reusable hardware is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. Environmental sensors play a critical role in the ISCAPE project the primary goals being: Engage local communities at the Living Labs to deploy and learn about sensors as a novel way to learn about their environment, in particular cities air pollution issues. Provide a sensor infrastructure to enable the different sites to monitor the performance of their interventions. To support this approach, we needed to accomplish three key requirements: Modularity: The sensor hardware operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes. Open design and documentation: All the components developed are released on open source license to foster the collaboration between different the stakeholders. That especially aims at involving the Living Labs on the design of new sensing strategies and technologies. Easy to use: The technology needs to be accessible to ensure users engagement, especially for those sensors targeting at citizens, but also to ensure the technology development is ready to be exploded commercially after the project. The following approach led the project to development of two sensor solutions: The Citizen Kit and the Living Lab Stations . The following website contains the full documentation of the software and hardware sensor platform developed for the project. It is aimed at any project stakeholder to learn how to use the different components and also to contribute on its future development.","title":"Introduction"},{"location":"#sections","text":"Main: Contains the Citizen Kit and Living Lab Stations documentation to help participants to use them. Components: Contains all the documentation on the different hardware sensor modules with detailed insights on the sensors behaviour and calibration. Sensor Analysis Framework: Contains all the documentation on the data post processing framework to obtain insights from the data calibrated by the sensors. Sensor Platform: Contains all the documentation on the sensors web platform were data is collected, stored and vizualized.","title":"Sections"},{"location":"#guides","text":"The documentation contains multiple guides as step-by-step tutorials to perform important tasks as installing a sensor type or uploadig the software on the sensors. Example guides Installing the Living Labs Station Installing the Citizen Kit Onboarding Sensors Uploading CSV Data Update the Firmware Edit the Firmware","title":"Guides"},{"location":"#open-source","text":"We're against black boxes! The entire project it is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Open Source"},{"location":"Citizen Kit/","text":"Citizen Kit Link The Citizen Kit, formerly known as the Low-Cost Sensor, is aimed at providing a low-cost environmental sensor solution non-technical users can easily deploy. The design developed for the project is a complete reiteration of the Smart Citizen Kit, a piece of hardware for citizen sensing already tested in other projects for more than five years. On this iteration, new sensors had been added, and all the electronic design has been redone from the ground up to improve the data accuracy and reduce the manufacturing costs. The design is built around two boards the Smart Citizen Data Board and the Smart Citizen Urban Sensor Board. The first board contains the data acquisition, the power management, and the communication unit. The second contains a set of sensors aimed at the outdoor urban environment including: Air Temperature, Relative Humidity, Noise Level, Ambient Light and Barometric Pressure. The board also features a section especially focused on Air Quality including a Air Particles, a Carbon Monoxide, and a Dioxide Nitrogen detectors. This sensor while not capable of offering precise measurements can be used to understand the behavior of different urban locations especially when they are calibrated on the field using certified equipment. Both boards are later described in detail on the Sensor Components section. From the non-technical user side, the sensor includes an easy to follow online setup process that guides the users on the whole install procedure: The Smart Citizen Onboarding. The sensor does not require to stay always powered but requires charging at least every two days. The charging is done using a standard USB adapter like on any Smartphone; a process already by many users familiar. Sensors Link Measurement Units Sensor Component Air Temperature \u00baC Sensirion SHT-21 Urban Sensor Board Relative Humidity % REL Sensirion SHT-21 Urban Sensor Board Noise Level dBA Invensense ICS-434342 Urban Sensor Board Ambient Light Lux Rohm BH1721FVC Urban Sensor Board Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Urban Sensor Board Carbon Monoxide ppm (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Dioxide Nitrogen ppb (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Particle Matter PM2.5 (external - power req) \u00b5g/m3 PMS 7003 Urban Sensor Board How to install? Link Onboarding app Visit the onboarding app at onboarding.iscape.smartcitizen.me Step by step Welcome page Select all the parts you received to ensure you are not missing any part Turn on your Kit Close the cover of your device Choose the Wi-Fi network you want to connect to You will reiceive a message when the Kit it is connected Add a name to your sensor Select the location for your sensor Add your email to register the Kit under your name Add a user name for people to see you on the platform Add a password to protect your account You are done! Visit the Kit on the platform. Wait one minute till it publishes data Look at the data! Technical specs Link Components Link The Citizen Kit is a modular system based on different sensor board that connected to a central datalogger. Citizen Kits Components Setup Learn more Learn more about all the components and the software inside the kit in the Components documentation section. Connectivity Link WI-FI Link The SCK 2.0 is designed to publish data using your home or office Wi-Fi. It currently supports most standard networks (b/g/n) with open, WEP or WPA/WPA2 authentication. WPA2 Enterprise networks are not currently supported. Internal memory Link The SCK 2.0 includes an internal memory to store more than one week\u2019s worth of data incase the device loses its Wi-Fi connection. Data is published automatically when the connection recovers. SD Card Link For operation in remote areas, the kit can store data in CSV format on an SD/SDHC MicroSD card with a standard FAT file system. Alternately, while in Wi-Fi mode when an SD card is in place, the kit also stores the published data on the SD card as a backup. In both cases, data can later be uploaded manually to the platform using the \u201cManual Data Upload\u201d option. Power Management Link Battery lifetime Link The SCK 2.0 comes with a 2000mAh LiPo battery. The battery is meant to be a complete power option for short-term measurements and a backup solution when the kit it is used for long periods. The battery lifetime lifetime is dependent on which sensors are enabled or disabled: All sensors publishing over Wi-Fi: 12 hrs. All sensors publishing on SD card: 13 hrs. Without air quality sensors over Wi-Fi: 10 days Without air quality sensors on SD card: 25 days Battery charging Link The SCK 2.0 has a micro USB port and can be charged like any Smartphone or Tablet using a dedicated adapter or a computer USB port. We recommend using a tablet power adaptor, instead of a computer USB port, for quicker charging. Autonomy can be extended by using a Power Bank, a 5V PV Panel, or with a through-glass induction charger (currently under development). Configuration And Updates Link Configuration Link Our online onboarding website guides you through the assembly and configuration process. You\u2019ll need a computer with an internet connection to start using the SCK 2.0. Software Updates Link The SCK 2.0 has two components that need periodic updates. The SCK 2.0 appears as a USB Storage device and the new firmware can be installed on your kit by simply downloading the new firmware release and then dragging and dropping into the SCK 2.0 device root folder. The Wi-Fi module firmware is updated automatically over-the-air every time the main processor firmware is updated. Physical Link Dimensions: 60 x 60 x 20 mm (approx.) Dimensions w/ enclosure: 110 x 110 x 50mm (approx.) Weight: 65 gr. Weight w/ enclosure: 160 gr.","title":"Citizen Kit"},{"location":"Citizen Kit/#citizen-kit","text":"The Citizen Kit, formerly known as the Low-Cost Sensor, is aimed at providing a low-cost environmental sensor solution non-technical users can easily deploy. The design developed for the project is a complete reiteration of the Smart Citizen Kit, a piece of hardware for citizen sensing already tested in other projects for more than five years. On this iteration, new sensors had been added, and all the electronic design has been redone from the ground up to improve the data accuracy and reduce the manufacturing costs. The design is built around two boards the Smart Citizen Data Board and the Smart Citizen Urban Sensor Board. The first board contains the data acquisition, the power management, and the communication unit. The second contains a set of sensors aimed at the outdoor urban environment including: Air Temperature, Relative Humidity, Noise Level, Ambient Light and Barometric Pressure. The board also features a section especially focused on Air Quality including a Air Particles, a Carbon Monoxide, and a Dioxide Nitrogen detectors. This sensor while not capable of offering precise measurements can be used to understand the behavior of different urban locations especially when they are calibrated on the field using certified equipment. Both boards are later described in detail on the Sensor Components section. From the non-technical user side, the sensor includes an easy to follow online setup process that guides the users on the whole install procedure: The Smart Citizen Onboarding. The sensor does not require to stay always powered but requires charging at least every two days. The charging is done using a standard USB adapter like on any Smartphone; a process already by many users familiar.","title":"Citizen Kit"},{"location":"Citizen Kit/#sensors","text":"Measurement Units Sensor Component Air Temperature \u00baC Sensirion SHT-21 Urban Sensor Board Relative Humidity % REL Sensirion SHT-21 Urban Sensor Board Noise Level dBA Invensense ICS-434342 Urban Sensor Board Ambient Light Lux Rohm BH1721FVC Urban Sensor Board Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Urban Sensor Board Carbon Monoxide ppm (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Dioxide Nitrogen ppb (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Particle Matter PM2.5 (external - power req) \u00b5g/m3 PMS 7003 Urban Sensor Board","title":"Sensors"},{"location":"Citizen Kit/#how-to-install","text":"Onboarding app Visit the onboarding app at onboarding.iscape.smartcitizen.me Step by step Welcome page Select all the parts you received to ensure you are not missing any part Turn on your Kit Close the cover of your device Choose the Wi-Fi network you want to connect to You will reiceive a message when the Kit it is connected Add a name to your sensor Select the location for your sensor Add your email to register the Kit under your name Add a user name for people to see you on the platform Add a password to protect your account You are done! Visit the Kit on the platform. Wait one minute till it publishes data Look at the data!","title":"How to install?"},{"location":"Citizen Kit/#technical-specs","text":"","title":"Technical specs"},{"location":"Citizen Kit/#components","text":"The Citizen Kit is a modular system based on different sensor board that connected to a central datalogger. Citizen Kits Components Setup Learn more Learn more about all the components and the software inside the kit in the Components documentation section.","title":"Components"},{"location":"Citizen Kit/#connectivity","text":"","title":"Connectivity"},{"location":"Citizen Kit/#wi-fi","text":"The SCK 2.0 is designed to publish data using your home or office Wi-Fi. It currently supports most standard networks (b/g/n) with open, WEP or WPA/WPA2 authentication. WPA2 Enterprise networks are not currently supported.","title":"WI-FI"},{"location":"Citizen Kit/#internal-memory","text":"The SCK 2.0 includes an internal memory to store more than one week\u2019s worth of data incase the device loses its Wi-Fi connection. Data is published automatically when the connection recovers.","title":"Internal memory"},{"location":"Citizen Kit/#sd-card","text":"For operation in remote areas, the kit can store data in CSV format on an SD/SDHC MicroSD card with a standard FAT file system. Alternately, while in Wi-Fi mode when an SD card is in place, the kit also stores the published data on the SD card as a backup. In both cases, data can later be uploaded manually to the platform using the \u201cManual Data Upload\u201d option.","title":"SD Card"},{"location":"Citizen Kit/#power-management","text":"","title":"Power Management"},{"location":"Citizen Kit/#battery-lifetime","text":"The SCK 2.0 comes with a 2000mAh LiPo battery. The battery is meant to be a complete power option for short-term measurements and a backup solution when the kit it is used for long periods. The battery lifetime lifetime is dependent on which sensors are enabled or disabled: All sensors publishing over Wi-Fi: 12 hrs. All sensors publishing on SD card: 13 hrs. Without air quality sensors over Wi-Fi: 10 days Without air quality sensors on SD card: 25 days","title":"Battery lifetime"},{"location":"Citizen Kit/#battery-charging","text":"The SCK 2.0 has a micro USB port and can be charged like any Smartphone or Tablet using a dedicated adapter or a computer USB port. We recommend using a tablet power adaptor, instead of a computer USB port, for quicker charging. Autonomy can be extended by using a Power Bank, a 5V PV Panel, or with a through-glass induction charger (currently under development).","title":"Battery charging"},{"location":"Citizen Kit/#configuration-and-updates","text":"","title":"Configuration And Updates"},{"location":"Citizen Kit/#configuration","text":"Our online onboarding website guides you through the assembly and configuration process. You\u2019ll need a computer with an internet connection to start using the SCK 2.0.","title":"Configuration"},{"location":"Citizen Kit/#software-updates","text":"The SCK 2.0 has two components that need periodic updates. The SCK 2.0 appears as a USB Storage device and the new firmware can be installed on your kit by simply downloading the new firmware release and then dragging and dropping into the SCK 2.0 device root folder. The Wi-Fi module firmware is updated automatically over-the-air every time the main processor firmware is updated.","title":"Software Updates"},{"location":"Citizen Kit/#physical","text":"Dimensions: 60 x 60 x 20 mm (approx.) Dimensions w/ enclosure: 110 x 110 x 50mm (approx.) Weight: 65 gr. Weight w/ enclosure: 160 gr.","title":"Physical"},{"location":"Living Lab Station/","text":"Living Lab Station Link The Living Lab Station, formerly known as the High-End Sensors, is aimed at providing the Living Labs with a system for monitoring the performance of their interventions. The Station aims at providing a solution that can be used by the Living Labs not just from a scientific point of view but also as a tool to engage local communities on air pollution related issues. The station is designed with a modular principle where sensors can be added easily added expanding the capabilities of the installation or replaced when they are damaged or the sensors lifetime is over. From a costs perspective while being more expensive than the Citizen Kit it is also conceived as a low-cost solution. That allows to guarantee at least four stations will be available for each Living Lab to increase the spatial resolution and reliability of the measurements. The design builds on top of the Citizen Kit adding an extra set of more accurate sensors especially aimed at measuring air pollutants. The sensors include the Gas Sensor Board, featuring EC Carbon Monoxide, Dioxide Nitrogen and Ozone sensors and the PM Sensor Board, featuring a PM 2.5 / PM 10 sensor. With all the sensor together this Kit provides information on Air Temperature, Relative Humidity, Noise Level, Ambient Light, Barometric Pressure, Particles Matter (PM 2.5 / 10), Carbon Monoxide, Dioxide Nitrogen and Ozone. The sensors are later described in detail in the document at the Sensor Components section. Sensors Link Measurement Units Sensor Component Air Temperature \u00baC Sensirion SHT-21 Urban Sensor Board Relative Humidity % REL Sensirion SHT-21 Urban Sensor Board Noise Level dBA Invensense ICS-434342 Urban Sensor Board Ambient Light Lux Rohm BH1721FVC Urban Sensor Board Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Urban Sensor Board Carbon Monoxide \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Dioxide Nitrogen \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Particle Matter PM2.5 (external - power req) \u00b5g/m3 PMS 7003 Urban Sensor Board Carbon Monoxide ppm Alphasense CO-B4 Gas Sensor Pro Board Dioxide Nitrogen ppb Alphasense NO2-B43F Gas Sensor Pro Board Ozone ppb Alphasense OX-B431 Gas Sensor Pro Board PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 10 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board Components Link The Living Labs Station is a modular system based on different sensor board that connected to a central datalogger. Living Lab Stations Components Setup The station operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes. Learn more Learn more about all the components and the software inside the station in the Components documentation section. How to install? Link Parts Link iSCAPE Living Lab Station Urban Board 2.0 Data Board 2.0 PM Board 2.0 + 2 PM sensors Gas Pro Board 2.0 with 3 EC sensors 6Ah Battery Accessories MicroSD card 512MB USB Charger MicroSD to SD card adapter USB Power Supply 2m 3 Wire 220V cable Mounting brackets and screws Mounting tools (1x Wrench + 2 Allen Keys) Assembly and configuration Link The sensors are already assembled and we strongly require to not swap any of the sensors among them. Warning We keep track internally of all sensor deployments and it is very important not to swap the internal components between Station to avoid mismatchs on the calibration data. Step by step You have to follow some simple steps to setup your SCK to capture data and store it on an SD card: Remove the 3 protective stickers covering the Gas Sensors. Use the small allen key to unscrew the 3 screw on top. Remove the top cover Use the big allen to remove the 3 screw. Pull the cover out. Make sure the SD card is inserted in the kit. Connect the battery to your SCK. The led should turn pink indicating SD card logging. The SCK will try to start immediately, but since the clock is not yet configured it will blink for 5 seconds and the led will turn red (setup mode). Syncronize the RTC (Real Time Clock) of the SCK with UTC time . The simplest way of doing this is to join to your SCK WiFi network: With your computer or smartphone search for a wifi network named SmartCitizenXXXX (The exact name should come in a sticker in the back of your kit). Once you join the network a Network Login screen should appear, if this doesn't happen open your browser and type 192.168.1.1 as the URL. Go to SD Card Mode Once the time it's sync the led should turn pink again and your sensor will start logging data to the SD card. Congratulations! You are ready close the enclosure and start capturing data. Warning The configuration of enabled/disabled sensors is stored on the SDcard so the cards shouldn't be swaped between kits. Warning If you have problems with a SD Card be sure to format it with FAT32 filesystem and don't copy any configuration file before inserting it on the kit, the kit will re-save the last valid configuration on the new sdcard. Done for today? Turn off Every time you want to stop the Kit from logging simply press the button for 5 seconds. The led should stop bliking and your Kit will be OFF . To turn it ON simply press the button again. Get your data Download the data from the SD card First turn off your Kit by pressing the button for 5 seconds. Then remove the micro SD card and plug the card on your computer using a Micro SD card reader. You will find inside a YYYY-MM-DD.CSV with all the data. Check the SD card file description section for more info. Data processing The collected data requires a custom and complex data processing using the iScape Sensor Analysis Framework The process will be fully documented here on the next few weeks. Is your Kit not working properly? Factory reset This will fully reset the Kit and should help you fix any issues you might have. Disconnect and connect the battery without any USB cable being connected. Then press the button until the light goes off and on again (around 15 sec). Sensor data collection Link The data will be collected in SD card mode during this deployment. Upload data from the SD card manually Read the documentation on Manual CSV data upload Sensor considerations Link Electrochemical sensor The electrochemical sensors need stabilisation time under the testing conditions they will be at. It is important to set and power the sensors with sufficient time (1-2 days) on the test environment for them to adapt. The newer the sensor, the more stabilisation time it requires. For this deployment, you will be receiving brand new sensors. Humidity and temperature extremes will require of further sensor adaptation, in order to dry out or absorb the necessary humidity for their proper functioning. Danger Do not extract/attach the sensor capsule from the base board while powered, this could irreversibly damage the sensor. Particle Sensor The particle sensors measurements are delivered as averages of the two sensors with periodic validity checks. We are currently developing one-shot strategies for battery life improvement, but in the meantime, please make sure the sensor has reliable energy supply if you will use these sensors permanently. Sensor data processing Link We have developed an algorithm that ingests the data from either the platform or the local csv and processes electrochemical sensor sensor data. This algorithm is in validation stage and will be included in the online platform flow from Smart Citizen once validated. Sensor Analysis Framework Learn more about the sensors calibration on the Sensor Analysis Framework section. Outdoor installation Link Use the perforated steel tape and the M6 provided to mount the Station on any street light or pole. The Pack also includes the required wrench. Setup the internal power supply Link The Station can be directly powered at 220V AC (Consumption MAX 33W). Batteries The Living Lab Station has a higher consumption, mostly due to the fans on the two PM sensors. That means the internal battery last just for 20h, and it is only aimed at providing backup power. For example, we can connect the station on the street light electric line, so the Station gets charged during the night when the lights are on. Solar Panel Unfortunately, we are having some problems with the PV Solar Panel system to power the Station independently. The system is currently under tests, and it will be available in the next few months. Step by step Remove the two covers using the allen keys as explained on the setup instructions. Remove the USB cable and bring inside the 220V power cable. Connect the cable wires with the power supply. Remove the third cover and place the power adapter as seen on the picture. Close the cover and run the Setup process again LED colors Link Red: The Station is in Setup Mode, this means that it is waiting to be configured. The Station will enter this mode (after blinking) when there is an error and some user action is required (ej. no SD card) once the problem is solved it will return to the original mode. You can enter this mode manually by clicking the button if you want to change configuration parameters. Pink Breathing: The Station is logging data to SD card. Everything it's all right! Blinking: The Station is trying to log data to SD card but there is a problem. You should try the setup process again. Battery feedback: When the Station is working on batteries the led will be on only when reading sensors or saving data. The rest of the time it will show a little blink every 2 seconds as a heartbeat. On low battery (less than 10%) the led will do a triple orange blink . If the Station is connected and charging the battery it will do a little orange blink every two seconds. When the battery is fully charged (or no battery is connected) this blink will turn green.","title":"Living Lab Station"},{"location":"Living Lab Station/#living-lab-station","text":"The Living Lab Station, formerly known as the High-End Sensors, is aimed at providing the Living Labs with a system for monitoring the performance of their interventions. The Station aims at providing a solution that can be used by the Living Labs not just from a scientific point of view but also as a tool to engage local communities on air pollution related issues. The station is designed with a modular principle where sensors can be added easily added expanding the capabilities of the installation or replaced when they are damaged or the sensors lifetime is over. From a costs perspective while being more expensive than the Citizen Kit it is also conceived as a low-cost solution. That allows to guarantee at least four stations will be available for each Living Lab to increase the spatial resolution and reliability of the measurements. The design builds on top of the Citizen Kit adding an extra set of more accurate sensors especially aimed at measuring air pollutants. The sensors include the Gas Sensor Board, featuring EC Carbon Monoxide, Dioxide Nitrogen and Ozone sensors and the PM Sensor Board, featuring a PM 2.5 / PM 10 sensor. With all the sensor together this Kit provides information on Air Temperature, Relative Humidity, Noise Level, Ambient Light, Barometric Pressure, Particles Matter (PM 2.5 / 10), Carbon Monoxide, Dioxide Nitrogen and Ozone. The sensors are later described in detail in the document at the Sensor Components section.","title":"Living Lab Station"},{"location":"Living Lab Station/#sensors","text":"Measurement Units Sensor Component Air Temperature \u00baC Sensirion SHT-21 Urban Sensor Board Relative Humidity % REL Sensirion SHT-21 Urban Sensor Board Noise Level dBA Invensense ICS-434342 Urban Sensor Board Ambient Light Lux Rohm BH1721FVC Urban Sensor Board Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Urban Sensor Board Carbon Monoxide \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Dioxide Nitrogen \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Particle Matter PM2.5 (external - power req) \u00b5g/m3 PMS 7003 Urban Sensor Board Carbon Monoxide ppm Alphasense CO-B4 Gas Sensor Pro Board Dioxide Nitrogen ppb Alphasense NO2-B43F Gas Sensor Pro Board Ozone ppb Alphasense OX-B431 Gas Sensor Pro Board PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 10 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board","title":"Sensors"},{"location":"Living Lab Station/#components","text":"The Living Labs Station is a modular system based on different sensor board that connected to a central datalogger. Living Lab Stations Components Setup The station operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes. Learn more Learn more about all the components and the software inside the station in the Components documentation section.","title":"Components"},{"location":"Living Lab Station/#how-to-install","text":"","title":"How to install?"},{"location":"Living Lab Station/#parts","text":"iSCAPE Living Lab Station Urban Board 2.0 Data Board 2.0 PM Board 2.0 + 2 PM sensors Gas Pro Board 2.0 with 3 EC sensors 6Ah Battery Accessories MicroSD card 512MB USB Charger MicroSD to SD card adapter USB Power Supply 2m 3 Wire 220V cable Mounting brackets and screws Mounting tools (1x Wrench + 2 Allen Keys)","title":"Parts"},{"location":"Living Lab Station/#assembly-and-configuration","text":"The sensors are already assembled and we strongly require to not swap any of the sensors among them. Warning We keep track internally of all sensor deployments and it is very important not to swap the internal components between Station to avoid mismatchs on the calibration data. Step by step You have to follow some simple steps to setup your SCK to capture data and store it on an SD card: Remove the 3 protective stickers covering the Gas Sensors. Use the small allen key to unscrew the 3 screw on top. Remove the top cover Use the big allen to remove the 3 screw. Pull the cover out. Make sure the SD card is inserted in the kit. Connect the battery to your SCK. The led should turn pink indicating SD card logging. The SCK will try to start immediately, but since the clock is not yet configured it will blink for 5 seconds and the led will turn red (setup mode). Syncronize the RTC (Real Time Clock) of the SCK with UTC time . The simplest way of doing this is to join to your SCK WiFi network: With your computer or smartphone search for a wifi network named SmartCitizenXXXX (The exact name should come in a sticker in the back of your kit). Once you join the network a Network Login screen should appear, if this doesn't happen open your browser and type 192.168.1.1 as the URL. Go to SD Card Mode Once the time it's sync the led should turn pink again and your sensor will start logging data to the SD card. Congratulations! You are ready close the enclosure and start capturing data. Warning The configuration of enabled/disabled sensors is stored on the SDcard so the cards shouldn't be swaped between kits. Warning If you have problems with a SD Card be sure to format it with FAT32 filesystem and don't copy any configuration file before inserting it on the kit, the kit will re-save the last valid configuration on the new sdcard. Done for today? Turn off Every time you want to stop the Kit from logging simply press the button for 5 seconds. The led should stop bliking and your Kit will be OFF . To turn it ON simply press the button again. Get your data Download the data from the SD card First turn off your Kit by pressing the button for 5 seconds. Then remove the micro SD card and plug the card on your computer using a Micro SD card reader. You will find inside a YYYY-MM-DD.CSV with all the data. Check the SD card file description section for more info. Data processing The collected data requires a custom and complex data processing using the iScape Sensor Analysis Framework The process will be fully documented here on the next few weeks. Is your Kit not working properly? Factory reset This will fully reset the Kit and should help you fix any issues you might have. Disconnect and connect the battery without any USB cable being connected. Then press the button until the light goes off and on again (around 15 sec).","title":"Assembly and configuration"},{"location":"Living Lab Station/#sensor-data-collection","text":"The data will be collected in SD card mode during this deployment. Upload data from the SD card manually Read the documentation on Manual CSV data upload","title":"Sensor data collection"},{"location":"Living Lab Station/#sensor-considerations","text":"Electrochemical sensor The electrochemical sensors need stabilisation time under the testing conditions they will be at. It is important to set and power the sensors with sufficient time (1-2 days) on the test environment for them to adapt. The newer the sensor, the more stabilisation time it requires. For this deployment, you will be receiving brand new sensors. Humidity and temperature extremes will require of further sensor adaptation, in order to dry out or absorb the necessary humidity for their proper functioning. Danger Do not extract/attach the sensor capsule from the base board while powered, this could irreversibly damage the sensor. Particle Sensor The particle sensors measurements are delivered as averages of the two sensors with periodic validity checks. We are currently developing one-shot strategies for battery life improvement, but in the meantime, please make sure the sensor has reliable energy supply if you will use these sensors permanently.","title":"Sensor considerations"},{"location":"Living Lab Station/#sensor-data-processing","text":"We have developed an algorithm that ingests the data from either the platform or the local csv and processes electrochemical sensor sensor data. This algorithm is in validation stage and will be included in the online platform flow from Smart Citizen once validated. Sensor Analysis Framework Learn more about the sensors calibration on the Sensor Analysis Framework section.","title":"Sensor data processing"},{"location":"Living Lab Station/#outdoor-installation","text":"Use the perforated steel tape and the M6 provided to mount the Station on any street light or pole. The Pack also includes the required wrench.","title":"Outdoor installation"},{"location":"Living Lab Station/#setup-the-internal-power-supply","text":"The Station can be directly powered at 220V AC (Consumption MAX 33W). Batteries The Living Lab Station has a higher consumption, mostly due to the fans on the two PM sensors. That means the internal battery last just for 20h, and it is only aimed at providing backup power. For example, we can connect the station on the street light electric line, so the Station gets charged during the night when the lights are on. Solar Panel Unfortunately, we are having some problems with the PV Solar Panel system to power the Station independently. The system is currently under tests, and it will be available in the next few months. Step by step Remove the two covers using the allen keys as explained on the setup instructions. Remove the USB cable and bring inside the 220V power cable. Connect the cable wires with the power supply. Remove the third cover and place the power adapter as seen on the picture. Close the cover and run the Setup process again","title":"Setup the internal power supply"},{"location":"Living Lab Station/#led-colors","text":"Red: The Station is in Setup Mode, this means that it is waiting to be configured. The Station will enter this mode (after blinking) when there is an error and some user action is required (ej. no SD card) once the problem is solved it will return to the original mode. You can enter this mode manually by clicking the button if you want to change configuration parameters. Pink Breathing: The Station is logging data to SD card. Everything it's all right! Blinking: The Station is trying to log data to SD card but there is a problem. You should try the setup process again. Battery feedback: When the Station is working on batteries the led will be on only when reading sensors or saving data. The rest of the time it will show a little blink every 2 seconds as a heartbeat. On low battery (less than 10%) the led will do a triple orange blink . If the Station is connected and charging the battery it will do a little orange blink every two seconds. When the battery is fully charged (or no battery is connected) this blink will turn green.","title":"LED colors"},{"location":"_FAQ/","text":"Frequently asked questions Link Can the sensors be placed outdoors? Link Yes. The sensor is designed for both indoors and outdoors use. But if you\u2019re planning to use it outdoors, you will have to consider purchasing also a rainproof enclosure. Can I make my own rainproof enclosure? Link Of course! The manufacturing files for the 3D printed enclosure will be available to download. Throughout the history of the Smart Citizen project, we\u2019ve seen many inventive solutions for placing the sensor outdoors. Can I charge the sensors with a solar panel? Link Sure! But note that the sensor requires a 5V solar panel to work properly. Keeping that in mind, you can buy one of the photovoltaic panels that we provide, or run your own tests. Can I add external sensors to the system? Link Yes. The sensor has an independently configurable auxiliary bus at 3.3V with a SEEED Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART. It can supply power up to 750mA, and it can be enabled or disabled by software. What happens if there is a loss of network connectivity? Link If the sensor is working in network mode and at any time the network is not available, it will store the data on its internal memory and publish all the collected data as soon as the network is available again. Which external sensors can be added? Link For the moment, the list of supported sensors includes some Atlas Scientific probes, some Seeed Grove sensors, and the Chirp moisture sensor, but the options are almost endless. We will add tutorials to use the additional sensors listed above in our documentation.However, in the short term we will only offer support for them via our custom hardware development services. Will I be able to access the collected data? Link Of course! The data collected by your sensor is available for anyone on the Smart Citizen platform, and you can download it at any time as a CSV file. Besides, you can also use the API to built custom applications to interact with your device. How does the sensors record the data? Link The sensor can work in network and SD card modes. In network mode, the sensor publish data to the SC platform over Wi-Fi every minute. In SD card mode, all the collected data is stored locally in CSV format, and it can be later uploaded manually to the platform using the \u201cManual Data Upload\u201d option. Is there a mobile phone that lets me view the data? Link Currently, there is an android app available, but we are working to make the website fully mobile device friendly, so that no mobile phone app is required. We would rather focus the time of our small team on the kits themselves instead of maintaining apps. So our final aim is to be app free, but fully mobile friendly. How accurate are the measurements? Link Weather, noise, light and PM sensor measurements have been calibrated and validated against reference sensors through both in-house and external validations and they provide accurate data. Chemical gas sensors are to be considered qualitatively rather than quantitatively while calibration algorithms are developed for data accuracy improvement. Will the global platform be maintained after the project finishes release? Link Yes, it will be maintained just as it has been for the past five years. Also, the platform is fully open source so the community can take over the maintenance if at some point the Smart Citizen core team can no longer run it. Are there any notable case studies using similar sensors? Link Yes! A particularly interesting case study is the Making Sense project at Plac\u0327a del Sol in Barcelona, where a group of 15 technology enthusiasts and environmentalists joined a community of neighbours from a middle-class district that has been suffering from noise issues due to the nightlife in the square. You can find more information about this case study at: www.making-sense.eu What happens if i want to move the device or give it to someone else? Link With just one press of a button you can fully reset your sensor and configure it again using your account or a new one. All your previous data will remain available on the platform as it was before the reset. What about using other wireless technologies? Link We are working closely with Barcelona\u2019s The Things Network community to develop a TTN enabled sensor. A LoRA prototype has been tested, but we don\u2019t have dates for the final version yet. BLE, Zigbee, or others are not currently supported, and except for G5, we are not planning to implement them unless there is a custom hardware integration demand. Can I remove my data from the platform? Link Of course. You are the owner of the data that you collect, and you can download and/or delete all your sensor data at any time.","title":" FAQ"},{"location":"_FAQ/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"_FAQ/#can-the-sensors-be-placed-outdoors","text":"Yes. The sensor is designed for both indoors and outdoors use. But if you\u2019re planning to use it outdoors, you will have to consider purchasing also a rainproof enclosure.","title":"Can the sensors be placed outdoors?"},{"location":"_FAQ/#can-i-make-my-own-rainproof-enclosure","text":"Of course! The manufacturing files for the 3D printed enclosure will be available to download. Throughout the history of the Smart Citizen project, we\u2019ve seen many inventive solutions for placing the sensor outdoors.","title":"Can I make my own rainproof enclosure?"},{"location":"_FAQ/#can-i-charge-the-sensors-with-a-solar-panel","text":"Sure! But note that the sensor requires a 5V solar panel to work properly. Keeping that in mind, you can buy one of the photovoltaic panels that we provide, or run your own tests.","title":"Can I charge the sensors with a solar panel?"},{"location":"_FAQ/#can-i-add-external-sensors-to-the-system","text":"Yes. The sensor has an independently configurable auxiliary bus at 3.3V with a SEEED Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART. It can supply power up to 750mA, and it can be enabled or disabled by software.","title":"Can I add external sensors to the system?"},{"location":"_FAQ/#what-happens-if-there-is-a-loss-of-network-connectivity","text":"If the sensor is working in network mode and at any time the network is not available, it will store the data on its internal memory and publish all the collected data as soon as the network is available again.","title":"What happens if there is a loss of network connectivity?"},{"location":"_FAQ/#which-external-sensors-can-be-added","text":"For the moment, the list of supported sensors includes some Atlas Scientific probes, some Seeed Grove sensors, and the Chirp moisture sensor, but the options are almost endless. We will add tutorials to use the additional sensors listed above in our documentation.However, in the short term we will only offer support for them via our custom hardware development services.","title":"Which external sensors can be added?"},{"location":"_FAQ/#will-i-be-able-to-access-the-collected-data","text":"Of course! The data collected by your sensor is available for anyone on the Smart Citizen platform, and you can download it at any time as a CSV file. Besides, you can also use the API to built custom applications to interact with your device.","title":"Will I be able to access the collected data?"},{"location":"_FAQ/#how-does-the-sensors-record-the-data","text":"The sensor can work in network and SD card modes. In network mode, the sensor publish data to the SC platform over Wi-Fi every minute. In SD card mode, all the collected data is stored locally in CSV format, and it can be later uploaded manually to the platform using the \u201cManual Data Upload\u201d option.","title":"How does the sensors record the data?"},{"location":"_FAQ/#is-there-a-mobile-phone-that-lets-me-view-the-data","text":"Currently, there is an android app available, but we are working to make the website fully mobile device friendly, so that no mobile phone app is required. We would rather focus the time of our small team on the kits themselves instead of maintaining apps. So our final aim is to be app free, but fully mobile friendly.","title":"Is there a mobile phone that lets me view the data?"},{"location":"_FAQ/#how-accurate-are-the-measurements","text":"Weather, noise, light and PM sensor measurements have been calibrated and validated against reference sensors through both in-house and external validations and they provide accurate data. Chemical gas sensors are to be considered qualitatively rather than quantitatively while calibration algorithms are developed for data accuracy improvement.","title":"How accurate are the measurements?"},{"location":"_FAQ/#will-the-global-platform-be-maintained-after-the-project-finishes-release","text":"Yes, it will be maintained just as it has been for the past five years. Also, the platform is fully open source so the community can take over the maintenance if at some point the Smart Citizen core team can no longer run it.","title":"Will the global platform be maintained after the project finishes release?"},{"location":"_FAQ/#are-there-any-notable-case-studies-using-similar-sensors","text":"Yes! A particularly interesting case study is the Making Sense project at Plac\u0327a del Sol in Barcelona, where a group of 15 technology enthusiasts and environmentalists joined a community of neighbours from a middle-class district that has been suffering from noise issues due to the nightlife in the square. You can find more information about this case study at: www.making-sense.eu","title":"Are there any notable case studies using similar sensors?"},{"location":"_FAQ/#what-happens-if-i-want-to-move-the-device-or-give-it-to-someone-else","text":"With just one press of a button you can fully reset your sensor and configure it again using your account or a new one. All your previous data will remain available on the platform as it was before the reset.","title":"What happens if i want to move the device or give it to someone else?"},{"location":"_FAQ/#what-about-using-other-wireless-technologies","text":"We are working closely with Barcelona\u2019s The Things Network community to develop a TTN enabled sensor. A LoRA prototype has been tested, but we don\u2019t have dates for the final version yet. BLE, Zigbee, or others are not currently supported, and except for G5, we are not planning to implement them unless there is a custom hardware integration demand.","title":"What about using other wireless technologies?"},{"location":"_FAQ/#can-i-remove-my-data-from-the-platform","text":"Of course. You are the owner of the data that you collect, and you can download and/or delete all your sensor data at any time.","title":"Can I remove my data from the platform?"},{"location":"Components/","text":"Components Link The project sensor platform builds on the legacy of previous Smart Citizen Kit generations to develop a new set of tools especially aimed at providing meaningful data insights on a low budget. That means this report documents new components, developed specifically for the project, but frames them inside the Smart Citizen ecosystem. We believe building modular and reusable hardware is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. The sensor hardware operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes. Hardware Link Data Board: A datalogger on asteroids and the heart of the sensors architecure supporting the Citizen Kit and the Living Lab Stations . Firmware: The software running inside the sensors. Sensor Board: Multiple sensor board have been developed. They can be combined to built the different sensor solutions as the Citizen Kit and the Living Lab Stations . Urban Sensor Board: A selection of low-cost sensors in a board ready to measure the urban environment: temperature, humidity, noise and even PM2.5. Together with the Data Board they create the Citizen Kit . PM Sensor Board: An auxiliary board capable of driving two Particulate Matter sensor as well as other auxiliary sensors required for specific deployments as an external temperature sensor or an anemometer. It is used in the Living Lab Stations . Gas Pro Sensor Board: An auxiliary board driving 3 Alphasense Ltd. Electrochemical Series B Gas Sensors designed for ultra-low noise, high-performance and low power operation. It is used in the Living Lab Stations . Open Source Link We're against black boxes! The entire project it is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Index"},{"location":"Components/#components","text":"The project sensor platform builds on the legacy of previous Smart Citizen Kit generations to develop a new set of tools especially aimed at providing meaningful data insights on a low budget. That means this report documents new components, developed specifically for the project, but frames them inside the Smart Citizen ecosystem. We believe building modular and reusable hardware is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. The sensor hardware operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes.","title":"Components"},{"location":"Components/#hardware","text":"Data Board: A datalogger on asteroids and the heart of the sensors architecure supporting the Citizen Kit and the Living Lab Stations . Firmware: The software running inside the sensors. Sensor Board: Multiple sensor board have been developed. They can be combined to built the different sensor solutions as the Citizen Kit and the Living Lab Stations . Urban Sensor Board: A selection of low-cost sensors in a board ready to measure the urban environment: temperature, humidity, noise and even PM2.5. Together with the Data Board they create the Citizen Kit . PM Sensor Board: An auxiliary board capable of driving two Particulate Matter sensor as well as other auxiliary sensors required for specific deployments as an external temperature sensor or an anemometer. It is used in the Living Lab Stations . Gas Pro Sensor Board: An auxiliary board driving 3 Alphasense Ltd. Electrochemical Series B Gas Sensors designed for ultra-low noise, high-performance and low power operation. It is used in the Living Lab Stations .","title":"Hardware"},{"location":"Components/#open-source","text":"We're against black boxes! The entire project it is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Open Source"},{"location":"Components/Data Board/","text":"Data Board Link The data board is the heart of the sensors architecure, powered by an ARM M0+ 32-bits at 48Mhz running the Smart Citizen 2.0 software, combining the low power consumption of the ARM M0 family with the power of a 32-bits processor with 32KB of RAM and 256KB FLASH memory. That offers enough program storage and memory space to support multiple auxiliary sensors and no expense. It also includes a Wi-Fi module, a micro SD card slot, an internal Flash and a battery management solution all on a single board. Check the source code The ARM M0+ is a SAM D21 from Atmel with 32kB RAM and 256 kB of program memory, operating at 3.3V. It is the same chip used by the Arduino Zero and MKR boards. It also includes 4MB of extra Flash Memory for offline data storage. The Wi-Fi Module is the well known Espressif ESP8266 IEEE 802.11 b/g/n Wi-Fi with 4MB Internal Flash for web content storage. The Data Board connects to the sensor board providing power, analog and digital communications (12 bits ADC, GPIO, I2C, I2S, VCC). Moreover, it includes a Seeed Studio standard Grove connector where off the shelf modules from the same manufacturer can be connected. The external add-ons can be enabled or disabled from the board to save power. The connector supports an independent I2C bus by default, but it can be configured in software to support other uses (GPIO, I2C and UART). The Smart Citizen Gas and Smart Citizen PM sensor boards described above use this bus receive power and communications from the board. The board includes a battery management controller with a 2000mAh Lithium polymer cell capable of powering the device in standby for more than two weeks. On a normal operation, the battery will last for more than a week to one day, when all the sensors are enabled and recording every minute. The controller allows the batteries to be easily charged using the boards micro USB connector using any standard USB power adapter like the ones used on Smartphones. On remote areas, it can also be powered using a selection of PV Panels like Voltaics Systems 6W panel. Light color codes Red soft pulsing Apmode Blue soft pulsing wifi. Pink soft pulsing sdcard. Other color + Orange soft pulsing on battery. Other color + Green soft pulsing battery charging. Firmware Link The firmware is built using the Arduino Zero with a custom variant for the Data Board main MCU. The ESP is also built using the Arduino ESP Core. Both firmwares are built and managed with Platform IO, an open-source IDE for embedded development. Platform IO features built-in dependency management and allows you to compile and upload both processors with a single command. Using the SWD ARM connector you can change the MCU bootloader and debug the firmware using Open Source tools. Info Learn more about the software running inside the Data Board on the Firmware section . Software guides Check the firmware guides and learn how to update and even modify the software: Debug the Firmware Edit the Firmware Update the Firmware Buses Link Sensor Boards connector Link The iSCAPE sensor feature a modular architecture where sensors can be updated independently by replacing any individual Sensor Board. The Sensor Boards features GPIO, ADC, I2C, UART and I2S connections at 3.3V. Currently, we only offer the Urban Sensor Board, but more boards are on the way, and you can even design and build a custom one. Example of a Sensor Board SAMD21 Pins Arduino Zero Pin SCK Pins SCK Conector SCK Conector SCK Pins Arduino Zero Pin SAMD21 Pins GND GND GND 16 15 GND GND GND GND GND GND 14 13 GND GND GND PA11 0 I2S_FS 12 11 TX A5 PB2 PA7 9 I2S_SD 10 9 RX 25 PB3 PA10 1 I2S_SCK 8 7 VBAT VBAT VBAT PA22 20 SDA 6 5 PWM_CO 13 PA9 PA23 21 SCL 4 3 PWM_NOX 14 PA8 VCC VCC VCC 2 1 VCC VCC VCC Auxiliary connector Link The Data Board features and independent configurable auxiliary bus at 3.3V with a SEEED Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART port. It can supply power up to 750mA, and it can be enabled or disabled by software. Example of devices connected via the AUX connector. Power management Link The power infrastructure of the Smart Citizen Kit 2.0 give us the possibility of running directly from a USB power source with or without lithium battery, it is composed by: * BQ24259 USB Charger that manages external power regulation, battery fast charging (up to 2Ah) and USB OTG that allow us powering other devices from the SCK. * BQ27426 Battery Fuel Gauge for precise battery level measuring. Normaly the SCK uses a 2000 mAh Lithium polymer battery but it is possible to take advantage of larger batteries. The charging current is regulated with a manual imposed limit that can be configured, and also auto adjusts to the connected USB charger capacity. The normal time for completely charging the stock battery is between 2 and 3 hours. It is also possible to use solar panel (5v) to charge the SCK. The power consumption of the kit depends on which sensors are enabled and how often they are read/published. Between readings the kit goes to sleep mode turning off almost all the subsystems and reducing the power consumption to almost nothing. The most problematic sensors in terms of power consumption are the MICS gas sensors (NO 2 and CO) which needs an always-on heater with a permanent consumption of around 50 mAh (35 hours per charge) and the PM sensor which needs a fan with a consumption of 35 mAh (50 hours per charge). We are working on pulse modes for both sensors that will allow us to turn them on for short periods take a reading and turn them off instantly. Without those sensors enabled the SCK can operate around a month posting data to sdcard every minute with one charge of 2000 mAh. The kit will operate normally: read sensors, post, got to sleep. Until the battery charge is below 3% when that threshold is passed it will enter an emergency sleep mode and interrupt all the normal functions until the charge goes over 5%. User feedback Link The charging and battery state information is showed through the led, with small flashes of different color depending on the state: USB cable connected Orange flash - the battery is charging Green flash - charge complete you can disconnect the kit No USB cable is connected No flash - charge is over 15% Orange flash and normal led Behavior (blue or pink breath) - charge is under 15% connect the charger! 3 ultra fast red flashes and NO other color - charge is under 3% (emergency sleep) connect the charger!! NO readings are taken!! Power consumption Link Boards Link Board ON Current Kit Basics (SAM + Basics, no ESP, no MICs) 16 with ESP 74 with MICS 65 ALL ON (KIT V2.0 without PMS) 120 Kit + Gas Pro Board Basics (SAM + Basics, no ESP, no MICs) 40 ALL ON 150 Kit + PM Board Basics 60 Kit + PM + Gas Pro Boards Basics 78 ALL ON (STATION) 350-390 Individual Components Link Component Current Kit (SAM + Basics, no ESP, no MICs) 16 MICS 50 ESP 60 Gas Pro Board (with alphasense) 25 PM Board 35 PMS5003 (each) 90-120* oscillating Source files Link Download Check the source code","title":"Index"},{"location":"Components/Data Board/#data-board","text":"The data board is the heart of the sensors architecure, powered by an ARM M0+ 32-bits at 48Mhz running the Smart Citizen 2.0 software, combining the low power consumption of the ARM M0 family with the power of a 32-bits processor with 32KB of RAM and 256KB FLASH memory. That offers enough program storage and memory space to support multiple auxiliary sensors and no expense. It also includes a Wi-Fi module, a micro SD card slot, an internal Flash and a battery management solution all on a single board. Check the source code The ARM M0+ is a SAM D21 from Atmel with 32kB RAM and 256 kB of program memory, operating at 3.3V. It is the same chip used by the Arduino Zero and MKR boards. It also includes 4MB of extra Flash Memory for offline data storage. The Wi-Fi Module is the well known Espressif ESP8266 IEEE 802.11 b/g/n Wi-Fi with 4MB Internal Flash for web content storage. The Data Board connects to the sensor board providing power, analog and digital communications (12 bits ADC, GPIO, I2C, I2S, VCC). Moreover, it includes a Seeed Studio standard Grove connector where off the shelf modules from the same manufacturer can be connected. The external add-ons can be enabled or disabled from the board to save power. The connector supports an independent I2C bus by default, but it can be configured in software to support other uses (GPIO, I2C and UART). The Smart Citizen Gas and Smart Citizen PM sensor boards described above use this bus receive power and communications from the board. The board includes a battery management controller with a 2000mAh Lithium polymer cell capable of powering the device in standby for more than two weeks. On a normal operation, the battery will last for more than a week to one day, when all the sensors are enabled and recording every minute. The controller allows the batteries to be easily charged using the boards micro USB connector using any standard USB power adapter like the ones used on Smartphones. On remote areas, it can also be powered using a selection of PV Panels like Voltaics Systems 6W panel. Light color codes Red soft pulsing Apmode Blue soft pulsing wifi. Pink soft pulsing sdcard. Other color + Orange soft pulsing on battery. Other color + Green soft pulsing battery charging.","title":"Data Board"},{"location":"Components/Data Board/#firmware","text":"The firmware is built using the Arduino Zero with a custom variant for the Data Board main MCU. The ESP is also built using the Arduino ESP Core. Both firmwares are built and managed with Platform IO, an open-source IDE for embedded development. Platform IO features built-in dependency management and allows you to compile and upload both processors with a single command. Using the SWD ARM connector you can change the MCU bootloader and debug the firmware using Open Source tools. Info Learn more about the software running inside the Data Board on the Firmware section . Software guides Check the firmware guides and learn how to update and even modify the software: Debug the Firmware Edit the Firmware Update the Firmware","title":"Firmware"},{"location":"Components/Data Board/#buses","text":"","title":"Buses"},{"location":"Components/Data Board/#sensor-boards-connector","text":"The iSCAPE sensor feature a modular architecture where sensors can be updated independently by replacing any individual Sensor Board. The Sensor Boards features GPIO, ADC, I2C, UART and I2S connections at 3.3V. Currently, we only offer the Urban Sensor Board, but more boards are on the way, and you can even design and build a custom one. Example of a Sensor Board SAMD21 Pins Arduino Zero Pin SCK Pins SCK Conector SCK Conector SCK Pins Arduino Zero Pin SAMD21 Pins GND GND GND 16 15 GND GND GND GND GND GND 14 13 GND GND GND PA11 0 I2S_FS 12 11 TX A5 PB2 PA7 9 I2S_SD 10 9 RX 25 PB3 PA10 1 I2S_SCK 8 7 VBAT VBAT VBAT PA22 20 SDA 6 5 PWM_CO 13 PA9 PA23 21 SCL 4 3 PWM_NOX 14 PA8 VCC VCC VCC 2 1 VCC VCC VCC","title":"Sensor Boards connector"},{"location":"Components/Data Board/#auxiliary-connector","text":"The Data Board features and independent configurable auxiliary bus at 3.3V with a SEEED Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART port. It can supply power up to 750mA, and it can be enabled or disabled by software. Example of devices connected via the AUX connector.","title":"Auxiliary connector"},{"location":"Components/Data Board/#power-management","text":"The power infrastructure of the Smart Citizen Kit 2.0 give us the possibility of running directly from a USB power source with or without lithium battery, it is composed by: * BQ24259 USB Charger that manages external power regulation, battery fast charging (up to 2Ah) and USB OTG that allow us powering other devices from the SCK. * BQ27426 Battery Fuel Gauge for precise battery level measuring. Normaly the SCK uses a 2000 mAh Lithium polymer battery but it is possible to take advantage of larger batteries. The charging current is regulated with a manual imposed limit that can be configured, and also auto adjusts to the connected USB charger capacity. The normal time for completely charging the stock battery is between 2 and 3 hours. It is also possible to use solar panel (5v) to charge the SCK. The power consumption of the kit depends on which sensors are enabled and how often they are read/published. Between readings the kit goes to sleep mode turning off almost all the subsystems and reducing the power consumption to almost nothing. The most problematic sensors in terms of power consumption are the MICS gas sensors (NO 2 and CO) which needs an always-on heater with a permanent consumption of around 50 mAh (35 hours per charge) and the PM sensor which needs a fan with a consumption of 35 mAh (50 hours per charge). We are working on pulse modes for both sensors that will allow us to turn them on for short periods take a reading and turn them off instantly. Without those sensors enabled the SCK can operate around a month posting data to sdcard every minute with one charge of 2000 mAh. The kit will operate normally: read sensors, post, got to sleep. Until the battery charge is below 3% when that threshold is passed it will enter an emergency sleep mode and interrupt all the normal functions until the charge goes over 5%.","title":"Power management"},{"location":"Components/Data Board/#user-feedback","text":"The charging and battery state information is showed through the led, with small flashes of different color depending on the state: USB cable connected Orange flash - the battery is charging Green flash - charge complete you can disconnect the kit No USB cable is connected No flash - charge is over 15% Orange flash and normal led Behavior (blue or pink breath) - charge is under 15% connect the charger! 3 ultra fast red flashes and NO other color - charge is under 3% (emergency sleep) connect the charger!! NO readings are taken!!","title":"User feedback"},{"location":"Components/Data Board/#power-consumption","text":"","title":"Power consumption"},{"location":"Components/Data Board/#boards","text":"Board ON Current Kit Basics (SAM + Basics, no ESP, no MICs) 16 with ESP 74 with MICS 65 ALL ON (KIT V2.0 without PMS) 120 Kit + Gas Pro Board Basics (SAM + Basics, no ESP, no MICs) 40 ALL ON 150 Kit + PM Board Basics 60 Kit + PM + Gas Pro Boards Basics 78 ALL ON (STATION) 350-390","title":"Boards"},{"location":"Components/Data Board/#individual-components","text":"Component Current Kit (SAM + Basics, no ESP, no MICs) 16 MICS 50 ESP 60 Gas Pro Board (with alphasense) 25 PM Board 35 PMS5003 (each) 90-120* oscillating","title":"Individual Components"},{"location":"Components/Data Board/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Components/Firmware/","text":"Firmware Link The firmware is OOP and is entirely written in C++. Both processors the core ARM MCU and the ESP8266 WIFI are developed as part of the same framework integrating seemingly by using a set of bridge libraries that provide a unifies the RPC architecture. The follo software was partially developed by IAAC as part of the Making Sense project under the European Community's H2020 Programme Grant Agreement No. 688620. Firmware updates are done via the micro USB port using the Platform IO software available for Linux, Mac and Windows. Architecture Link Core Microcontroller Link Name Functions Pins Definition for the MCU pinout Sensors Definition for all the sensors supported Sensors Absracts the sensors on a common interface SckBase Manages the core operations: power, connectivity, peripherials SckAux Manages the sensors connected on the AUX connector SckUrban Manages the sensors on the Urban Sensor Board SckCharger Manages the battery charging process SckButton Manages users button interaction actions SckLed Manages light status for user feedback Commands Library to absracts the core features on to a simple shell interface ReadLight Manages configuration over light ReadSound Manages configuration over sound Dependencies Link Adafruit INA219 Library Adafruit MPL3115A2 Library Adafruit SHT31 Library Arduino Json Library Arduino Low Power@ Library ArduinoZero PMUX Report Library DS2482 Library FlashStorage Library FlashStorage MCP342X Library RadioHead Library RTCZero Library SdFat Library SmartCitizen Kit Gases Pro Board Library SparkFun BQ27441 Arduino Library SparkFun MAX3010x Library SPIFlash Library U8g2 Library WiFi Module Link Name Functions SckESP Runs all the Wi-Fi networking related functions Dependencies Link Time Library ArduinoJson Library RemoteDebug Library RemoteDebug Library RadioHead Library RadioHead Library PubSubclient Library Shared Link Name Functions Config Provides a shared configuration between the two MCUs Data management Link The board is capable of storing the recorded data offline on its internal dedicated flash memory of 8MB and later publish this over Wi-Fi connectivity provided by an Espressif ESP8266. Data is published using MQTT messages to the Smart Citizen Platform. NTP is used for syncing the built-in RTC. For long term offline storage, the board provides a standard microSD socket where card in the orders of GB can be employed. That ensures extended periods of data in the order of decades can be stored. Configuration Link The board firmware is fully customizable without requiring any changes to the core software. That includes enabling or disabling sensors, the sampling frequency of the sensors or the operation mode. There different configuration options: via the Serial Shell available when the board is connected over USB, editing the config.txt file when using a microSD card. Detecting : AlphaDelta 1 A ... found , Enabling AlphaDelta 1 A Detecting : AlphaDelta 1 W ... found , already enabled !!! Detecting : AlphaDelta 2 A ... found , already enabled !!! Detecting : AlphaDelta 2 W ... found , already enabled !!! Detecting : AlphaDelta 3 A ... found , already enabled !!! Detecting : AlphaDelta 3 W ... found , already enabled !!! Detecting : AlphaDelta Temperature ... found , already enabled !!! Detecting : AlphaDelta Humidity ... found , already enabled !!! Detecting : Groove ADC ... nothing ! Detecting : INA219 Bus voltage ... nothing ! Detecting : INA219 Shunt voltage ... nothing ! Detecting : INA219 Current ... nothing ! Detecting : INA219 Load voltage ... nothing ! Detecting : DS18B20 Water temperature ... nothing ! Detecting : Atlas PH ... nothing ! Detecting : Atlas Conductivity ... nothing ! Detecting : Atlas Specific gravity ... nothing ! Detecting : Atlas Dissolved Oxygen ... nothing ! Detecting : Atlas DO Saturation ... nothing ! Detecting : Groove OLED ... nothing ! Shell Link The firmware provides a comprehensive command shell over USB to manage all the kits functionalities for advanced users. Use any Serial console as screen , platformio device monitor , or the serial monitor on the Arduino IDE Example commands: SCK help SCK config -wifi myWifiName myPassword -token myToken -mode network Storage Link Configuration file CONFIG.TXT Link If this file doesn't exist it is generated by the kit with the factory defaults and after that it can be modified by both the user and the kit. SckBase :: resetConfigFile (); If the modification comes from the kit (sound, platform, etc) it should be saved to the flash and then to the SD. When the file is read from the SD if it is valid and different from the flash version the flash version should be updated. There is a problem in this approach: if the user insert and old scard with an old config without erasing it he can mess an newly configured kit. To solve this there is the possibility of having a first entry in the config file that is called something like user_modified and the user should modify this so the new config is loaded. If this flag is not true the sdcard config would be overwritten with the one in the flash. Warning on Factory Reset This file will be restored to default values in a factory reset event. Readings file POST.CSV Link This file is generated and updated by the kit. When a SD is detected this file will be synced with the flash version as the correct one. For this to work we need a fast way to compare the files. We need to test if this is doable in terms of speed. Maybe only do this when it is requested via a command or user input. There should be a way to know if a post has been uploaded to the platform, so when the kit doesn't have a wifi connection it saves the readings and publish them as soon as a network connection is available. Warning on Factory Reset This file will be restored to default values in a factory reset event. Debug log file DEBUG.CSV Link The debug file is generated and updated by the kit, only if the debug mode is enabled on the configuration. When the debug mode is enabled the verbosity level of this file is defined by the outlevel ( normal, verbose or silent ). Warning on Factory Reset This file will be restored to default values in a factory reset event. Source files Link Download Check the source code","title":"Index"},{"location":"Components/Firmware/#firmware","text":"The firmware is OOP and is entirely written in C++. Both processors the core ARM MCU and the ESP8266 WIFI are developed as part of the same framework integrating seemingly by using a set of bridge libraries that provide a unifies the RPC architecture. The follo software was partially developed by IAAC as part of the Making Sense project under the European Community's H2020 Programme Grant Agreement No. 688620. Firmware updates are done via the micro USB port using the Platform IO software available for Linux, Mac and Windows.","title":"Firmware"},{"location":"Components/Firmware/#architecture","text":"","title":"Architecture"},{"location":"Components/Firmware/#core-microcontroller","text":"Name Functions Pins Definition for the MCU pinout Sensors Definition for all the sensors supported Sensors Absracts the sensors on a common interface SckBase Manages the core operations: power, connectivity, peripherials SckAux Manages the sensors connected on the AUX connector SckUrban Manages the sensors on the Urban Sensor Board SckCharger Manages the battery charging process SckButton Manages users button interaction actions SckLed Manages light status for user feedback Commands Library to absracts the core features on to a simple shell interface ReadLight Manages configuration over light ReadSound Manages configuration over sound","title":"Core Microcontroller"},{"location":"Components/Firmware/#dependencies","text":"Adafruit INA219 Library Adafruit MPL3115A2 Library Adafruit SHT31 Library Arduino Json Library Arduino Low Power@ Library ArduinoZero PMUX Report Library DS2482 Library FlashStorage Library FlashStorage MCP342X Library RadioHead Library RTCZero Library SdFat Library SmartCitizen Kit Gases Pro Board Library SparkFun BQ27441 Arduino Library SparkFun MAX3010x Library SPIFlash Library U8g2 Library","title":"Dependencies"},{"location":"Components/Firmware/#wifi-module","text":"Name Functions SckESP Runs all the Wi-Fi networking related functions","title":"WiFi Module"},{"location":"Components/Firmware/#dependencies_1","text":"Time Library ArduinoJson Library RemoteDebug Library RemoteDebug Library RadioHead Library RadioHead Library PubSubclient Library","title":"Dependencies"},{"location":"Components/Firmware/#shared","text":"Name Functions Config Provides a shared configuration between the two MCUs","title":"Shared"},{"location":"Components/Firmware/#data-management","text":"The board is capable of storing the recorded data offline on its internal dedicated flash memory of 8MB and later publish this over Wi-Fi connectivity provided by an Espressif ESP8266. Data is published using MQTT messages to the Smart Citizen Platform. NTP is used for syncing the built-in RTC. For long term offline storage, the board provides a standard microSD socket where card in the orders of GB can be employed. That ensures extended periods of data in the order of decades can be stored.","title":"Data management"},{"location":"Components/Firmware/#configuration","text":"The board firmware is fully customizable without requiring any changes to the core software. That includes enabling or disabling sensors, the sampling frequency of the sensors or the operation mode. There different configuration options: via the Serial Shell available when the board is connected over USB, editing the config.txt file when using a microSD card. Detecting : AlphaDelta 1 A ... found , Enabling AlphaDelta 1 A Detecting : AlphaDelta 1 W ... found , already enabled !!! Detecting : AlphaDelta 2 A ... found , already enabled !!! Detecting : AlphaDelta 2 W ... found , already enabled !!! Detecting : AlphaDelta 3 A ... found , already enabled !!! Detecting : AlphaDelta 3 W ... found , already enabled !!! Detecting : AlphaDelta Temperature ... found , already enabled !!! Detecting : AlphaDelta Humidity ... found , already enabled !!! Detecting : Groove ADC ... nothing ! Detecting : INA219 Bus voltage ... nothing ! Detecting : INA219 Shunt voltage ... nothing ! Detecting : INA219 Current ... nothing ! Detecting : INA219 Load voltage ... nothing ! Detecting : DS18B20 Water temperature ... nothing ! Detecting : Atlas PH ... nothing ! Detecting : Atlas Conductivity ... nothing ! Detecting : Atlas Specific gravity ... nothing ! Detecting : Atlas Dissolved Oxygen ... nothing ! Detecting : Atlas DO Saturation ... nothing ! Detecting : Groove OLED ... nothing !","title":"Configuration"},{"location":"Components/Firmware/#shell","text":"The firmware provides a comprehensive command shell over USB to manage all the kits functionalities for advanced users. Use any Serial console as screen , platformio device monitor , or the serial monitor on the Arduino IDE Example commands: SCK help SCK config -wifi myWifiName myPassword -token myToken -mode network","title":"Shell"},{"location":"Components/Firmware/#storage","text":"","title":"Storage"},{"location":"Components/Firmware/#configuration-file-configtxt","text":"If this file doesn't exist it is generated by the kit with the factory defaults and after that it can be modified by both the user and the kit. SckBase :: resetConfigFile (); If the modification comes from the kit (sound, platform, etc) it should be saved to the flash and then to the SD. When the file is read from the SD if it is valid and different from the flash version the flash version should be updated. There is a problem in this approach: if the user insert and old scard with an old config without erasing it he can mess an newly configured kit. To solve this there is the possibility of having a first entry in the config file that is called something like user_modified and the user should modify this so the new config is loaded. If this flag is not true the sdcard config would be overwritten with the one in the flash. Warning on Factory Reset This file will be restored to default values in a factory reset event.","title":"Configuration file CONFIG.TXT"},{"location":"Components/Firmware/#readings-file-postcsv","text":"This file is generated and updated by the kit. When a SD is detected this file will be synced with the flash version as the correct one. For this to work we need a fast way to compare the files. We need to test if this is doable in terms of speed. Maybe only do this when it is requested via a command or user input. There should be a way to know if a post has been uploaded to the platform, so when the kit doesn't have a wifi connection it saves the readings and publish them as soon as a network connection is available. Warning on Factory Reset This file will be restored to default values in a factory reset event.","title":"Readings file POST.CSV"},{"location":"Components/Firmware/#debug-log-file-debugcsv","text":"The debug file is generated and updated by the kit, only if the debug mode is enabled on the configuration. When the debug mode is enabled the verbosity level of this file is defined by the outlevel ( normal, verbose or silent ). Warning on Factory Reset This file will be restored to default values in a factory reset event.","title":"Debug log file DEBUG.CSV"},{"location":"Components/Firmware/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Components/Firmware/guides/Debug the firmware/","text":"Introduction Link Sometimes (many times actually), our code won't do what we want it to do and we need to take a look at what it's doing. By using a debugger we will be able to see what is going on inside another program while it executes or even crashes. This is fairly straight forward when you code for a modern day computer, since most IDEs have a proper interface integrated for it. However, debugging a chip like the SAMD21 can sometimes be tricky and here is where it's interesting to use a debugging kit. Image Credit: XKCD To keep it simple: our final target is to be able to interact with the SAMD21 (or the chip) while it's executing the program and tell it to pause the execution, give us the value of some variables and then continue. We will release a fairly extensive report with documentation on this process, but for those interested in reading an overview on how to debug, this post can be a short introduction. So, here we go! The first item we need is the Open On-Chip Debugger (OpenOCD) which provides debugging with the assistance of a debug adapter . This adapter is a small hardware module which helps provide the right kind of electrical signaling to the target being debugged. These are required since the debug host, on which OpenOCD runs (i.e. your computer, a Raspberry PI...) won\u2019t usually have native support for such signaling, or the connector needed to hook up to the target. Image Credit: Smart Citizen These adapters are sometimes packaged as discrete dongles, which may generically be called hardware interface dongles (and are quite expensive). Some development boards also integrate them directly, which may let the development board connect directly to the debug host over USB (and sometimes also to power it over USB, like the Arduino Genuino Zero ). In the case of the Smart Citizen Kit , we have a SWD Adapter that supports Serial Wire Debug signaling to communicate with the ARM core . In our approach, using a complete open toolchain , OpenOCD is be running on a Raspberry Pi, and communicating with the SCK's SWD through the GPIO pins of the Pi. GDB- OpenOCD: Let's debug the SCK OpenOCD- GDB: OK! OpenOCD- SCK: We are debugging you Note right of SCK: SCK thinks SCK- OpenOCD: OK! GDB- OpenOCD: Load firmware GDB- OpenOCD: Set Breakpoints OpenOCD- SCK: Do it! OpenOCD- SCK: Run! Note right of SCK: SCK runs Note right of SCK: SCK hits a breakpoint SCK- GDB: Temperature sensor reading is 500\u00baC Note left of GDB: Oh, oh... Finally, to be able to actually see what is going on inside our firmware while it executes , we need something that is able to read and understand the machine code and hand it over to a human understandable interface. This is where GDB kicks in and helps us by: Starting our program, specifying anything that might affect its behavior. Make our program stop on specified conditions. Examine what has happened when our program has stopped. Change things in our program, so we can experiment with correcting the effects of one bug and go on to learn about another. GDB and OpenOCD will be running in a Raspberry Pi hooked up to the SWD interface of the SCK, and we will see what's going on in them from our computer's terminal via SSH. Fairly simple , right? Now, we can make some changes to our code, make GDB flash it to the SCK and keep debugging in a completely open toolchain! Debugger setup using a Raspberry Pi Link First download and copy Raspbian Lite to your SDcard, here are the installation docs . Add wifi configuration Create a file name wpa_supplicant.conf on the /boot partition of the SD card, the content of this file should looks like this: ```shell= ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\"wifi_ssid\" psk=\"wifi_password\" } ``` Replacing wifi_ssid and wifi_password with your actual wifi network information. The wpa_supplicant.conf file will be copied to /etc/wpa_supplicant/ directory automatically once the Raspberry Pi is booted up. Enable SSH server. SSH access is disabled as default for security reasons. To enable the SSH server when Raspberry Pi is booted up for the first time: create a file called ssh with no file extension and no contents, and copy it to the /boot partition on the SD card. Find your raspberry on the network In order to find a raspberry pi over the network we can use commands like these: Linux ```shell= MY_IP_RANGE=$(ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}') nmap -sn MY_IP_RANGE IP= MY_IP_RANGE && IP= (arp -na | grep b8:27:eb | grep -Eo '[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}') ssh $IP; **Mac** (To be reviewed) ```shell= MY_RANGE=$(ip addr | grep UP -A3 | grep 192 -A0 | awk {print $2} ) nmap -sn $MY_RANGE arp -na | grep b8:27:eb SSH login without password: Si nunca has generado RSA key: ssh-keygen sin poner nada en la passphrase. Copiar la clave a la raspberry: ssh-copy-id -i ~/.ssh/id_rsa.pub raspi-address Ya que est\u00e9 lista la raspberry con conectarla debe bootear y conectarse sola a la red, el commando que esta arriba ( MY_IP... ) la localiza y hace ssh login. Once you are logged to your raspberry pi and connected to the internet, do a system upgrade : ```shell= sudo apt-get install rpi-update sudo rpi-update sudo apt-get update sudo apt-get dist-upgrade Install some **dependencies**: ```shell= sudo apt-get install git autoconf libtool make pkg-config libusb-1.0-0 libusb-1.0-0-dev telnet sshfs Openocd installation Link Clon openocd repository and compile: shell=git clone git://git.code.sf.net/p/openocd/code openocd-codecd openocd-code./bootstrap./configure --enable-sysfsgpio --enable-bcm2835gpiomakesudo make install\u0002wzxhzdk:3\u0003You can store this file in OpenOCD scripts dir so it will auto find it shell= sudo mv sck.cfg /usr/local/share/openocd/scripts/ and then run the OpenOCD server with: ```shell= sudo openocd -f sck.cfg Then you can connect to OpenOCD, if you want to connect from an external computer, replace 127.0.0.1 with your Raspberry Pi IP address. shell=telnet 127.0.0.1 4444\u0002wzxhzdk:5\u0003Then you can connect to OpenOCD from your computer with: shell= telnet raspi_address 4444 ### Uploading Arduino original bootloader * Get the bootloader file [here](https://github.com/arduino/ArduinoCore-samd/tree/master/bootloaders/zero) and build it. * Connect to OpenOCD server and run: ```shell= reset halt at91samd bootloader 0 at91samd chip-erase program samd21_sam_ba.bin verify at91samd bootloader 8192 reset run If you don't see any error youre done! Uploading SCK Firmware Link Install platformio, download and build SCK firmware Connect to OpenOCD server and run: `shell=reset haltflash write_image firmware.bin 8192verify_image firmware.bin 8192reset runreset run GDB Link General description Link The purpose of a debugger such as GDB is to allow you to see what is going on \u201cinside\u201d another program while it executes\u2014or what another program was doing at the moment it crashed. GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act: * Start your program, specifying anything that might affect its behavior. * Make your program stop on specified conditions. * Examine what has happened, when your program has stopped. * Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another. Debugging session with Raspberry Pi as the OpenOCD server Link Once your raspberry pi is setup with above instructions you can just do: ```shell= ssh pi@RaspberryAddress sudo openocd -f sck.cfg cd /platformio_project/path arm-none-eabi-gdb ./pioenvs/zeroUSB/firmware.elf (gdb) target remote RaspberryAddress:3333 (gdb) monitor reset run If you are using *platformio*, you need to modify the compiling option to avoid optimisation with -0g message to the compiler. In case you are not using *platformio*, activate verbose compiling output at Arduino IDE and find your compiled .elf directory. [env:zeroUSB] platform = atmelsam board = zeroUSB framework = arduino build_flags = -Og Now we are all set and ready to go. The debugger is waiting for instructions on the execution, which we detail below. !!! info **Quick handy instructions inside GDB environment** 1. *(gdb)* appears in every line and you don t have to type it each time 2. In case you need to exit GDB, just type in `quit`, but remember always killing the process before, should you have a target running ```shell= (gdb) kill (gdb) quit ``` 3. `RET` repeats the previous command ### GDB commands All commands in gdb during debugging are detailed in the GDB guide, chapter [GDB commands in detail (continue and stepping)](https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html) An **extract** of some useful commands are detailed below: #### Continuing and stepping `continue [ignore-count]` * Resumes program execution until next breakpoint. `[ignore-count]` argument allows to specify a further number of times to ingore a breakpoint. ```shell= (gdb) continue Continuing. Breakpoint 1, tick () at src/HOLA.cpp:9 9 void tick() { step count Continues running your program until control reaches a different source line , only availabe for source lines and functions compiled with debugging information. count is optional and states the number of steps to be performed before stopping, if no breakpoint arrives earlier. next [count] Continue to the next source line without going into functions . It has the same functionality as step, but it stays in the same stack frame. count works as in step count . As well, it understands jumps calls as in the end of for loops and return to the beginning of the loop. Info set step-mode on/off sets the behaviour of (gdb) when stepping into a function with no debugging information. In the case of step-mode on , it inspects the first line of code of the function, whereas on step-mode off it skips the function completely. finish Continue running until just after function in the selected stack frame returns . until Has the same behaviour as step , but it ignores the jumps between lines due to loops (for, whiles, etc), continuing to the next source code with incremental line number. Breakpoints Link info breakpoints Retrieve information about breakpoints ```shell= (gdb) info breakpoints Num Type Disp Enb ress What 1 breakpoint keep y 0x00002140 in tick() at src/HOLA.cpp:9 breakpoint already hit 15 times `break` * Set a breakpoint in a specific function ```shell= (gdb) break loop Set a breakpoint in a specific line (344) ```shell= (gdb) break main.cpp:344 !!! info Use the **tbreak** command instead of break if you want to stop the program once, and then remove the breakpoint. More **breakpoint condition** options can be found [**here**](https://sourceware.org/gdb/current/onlinedocs/gdb/Conditions.html#Conditions) you can find `watchpoint` * Set a watchpoint [**watchpoint**](https://sourceware.org/gdb/current/onlinedocs/gdb/Set-Watchpoints.html#Set-Watchpoints) to only stop once a variable has a certain value. ```shell= (gdb) watch timer Info Type in info watchpoints to get information about watchpoints. commands Set a list of actions related to the breakpoint: ```shell= break main.cpp:50 commands silent printf \"count is %d\\n\",count cont end `delete` * Delete a breakpoint ```shell= (gdb) delete 1 (gdb) info breakpoints No breakpoints or watchpoints. Printing / setting variables and more Link loop Read what is around a certain function ``shell=(gdb) l loop25 //while (!Serial) {26 //; // wait for serial port to connect. Needed for native USB port only27 //}28 }2930 void loop() {31 // put your main code here, to run repeatedly:32 Serial.println( HOLA );33 tick();34 Serial.println(millis());\u0002wzxhzdk:12\u0003 set` Set variable to a certain value ```shell= (gdb) set timer = 0 #### Target commands (load) `load filename offset` * `Load` it is meant to make filename (an executable) available for debugging on the remote system\u2014by downloading it. `load` also records the filename symbol table in GDB, like the add-symbol-file command. The file is loaded at whatever address is specified in the executable, also into flash memory. ### Making changes in the code Anytime we make a change in the code, we don t need to reload the debugging session. We can easily do so by: 1. Compile the code: a. Define Shell build in Sublime Text and configure a build sytem with: ``` shell_cmd : cd .. pio run ``` Then, everytime you hit Ctrl+B (Cmd+B) and you use your custom build system, it will automatically use this option. b. Or hit `pio run` in another terminal located in your project root directory 2. In gdb, `load` file. This will reload the file defined at the beginning of your debugging session and upload it to the target ```shell= (gdb) load Loading section .text, size 0x2e50 lma 0x2000 Loading section .ramfunc, size 0x60 lma 0x4e50 Loading section .data, size 0x110 lma 0x4eb0 Start address 0x2910, load size 12224 Transfer rate: 3 KB/sec, 4074 bytes/write. Keep debugging GDB Console Link TUI Link GDB has a console GUI option available with the command line option --tui In the upper frame you can see the code that's being executed. GDB init file Link From this example dashboard we can generate a custom .gdbinit file for the SCK which will be placed in the HOME directory... (ON GOING) Info Would be interesting to generate a custom option for production validation and one for internal debugging purposes For references about where to locate the .gdbinit and more custom behaviour for gdb in general see here . GDB from Sublime Text Link Setup Platformio project with sublime Text Setup sublimeGDB Reference Link General GDB references and examples Link Debugging with GDB - Book Debugging example from GDB and OpenOCD Arduino zero example Additional notes from Platformio configuration Link How to set other DEBUG FLAGS About project configuration with Platformio init Check here for building an *.ini file with custom build target for debugging and production.","title":"Debug the firmware"},{"location":"Components/Firmware/guides/Debug the firmware/#introduction","text":"Sometimes (many times actually), our code won't do what we want it to do and we need to take a look at what it's doing. By using a debugger we will be able to see what is going on inside another program while it executes or even crashes. This is fairly straight forward when you code for a modern day computer, since most IDEs have a proper interface integrated for it. However, debugging a chip like the SAMD21 can sometimes be tricky and here is where it's interesting to use a debugging kit. Image Credit: XKCD To keep it simple: our final target is to be able to interact with the SAMD21 (or the chip) while it's executing the program and tell it to pause the execution, give us the value of some variables and then continue. We will release a fairly extensive report with documentation on this process, but for those interested in reading an overview on how to debug, this post can be a short introduction. So, here we go! The first item we need is the Open On-Chip Debugger (OpenOCD) which provides debugging with the assistance of a debug adapter . This adapter is a small hardware module which helps provide the right kind of electrical signaling to the target being debugged. These are required since the debug host, on which OpenOCD runs (i.e. your computer, a Raspberry PI...) won\u2019t usually have native support for such signaling, or the connector needed to hook up to the target. Image Credit: Smart Citizen These adapters are sometimes packaged as discrete dongles, which may generically be called hardware interface dongles (and are quite expensive). Some development boards also integrate them directly, which may let the development board connect directly to the debug host over USB (and sometimes also to power it over USB, like the Arduino Genuino Zero ). In the case of the Smart Citizen Kit , we have a SWD Adapter that supports Serial Wire Debug signaling to communicate with the ARM core . In our approach, using a complete open toolchain , OpenOCD is be running on a Raspberry Pi, and communicating with the SCK's SWD through the GPIO pins of the Pi. GDB- OpenOCD: Let's debug the SCK OpenOCD- GDB: OK! OpenOCD- SCK: We are debugging you Note right of SCK: SCK thinks SCK- OpenOCD: OK! GDB- OpenOCD: Load firmware GDB- OpenOCD: Set Breakpoints OpenOCD- SCK: Do it! OpenOCD- SCK: Run! Note right of SCK: SCK runs Note right of SCK: SCK hits a breakpoint SCK- GDB: Temperature sensor reading is 500\u00baC Note left of GDB: Oh, oh... Finally, to be able to actually see what is going on inside our firmware while it executes , we need something that is able to read and understand the machine code and hand it over to a human understandable interface. This is where GDB kicks in and helps us by: Starting our program, specifying anything that might affect its behavior. Make our program stop on specified conditions. Examine what has happened when our program has stopped. Change things in our program, so we can experiment with correcting the effects of one bug and go on to learn about another. GDB and OpenOCD will be running in a Raspberry Pi hooked up to the SWD interface of the SCK, and we will see what's going on in them from our computer's terminal via SSH. Fairly simple , right? Now, we can make some changes to our code, make GDB flash it to the SCK and keep debugging in a completely open toolchain!","title":"Introduction"},{"location":"Components/Firmware/guides/Debug the firmware/#debugger-setup-using-a-raspberry-pi","text":"First download and copy Raspbian Lite to your SDcard, here are the installation docs . Add wifi configuration Create a file name wpa_supplicant.conf on the /boot partition of the SD card, the content of this file should looks like this: ```shell= ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\"wifi_ssid\" psk=\"wifi_password\" } ``` Replacing wifi_ssid and wifi_password with your actual wifi network information. The wpa_supplicant.conf file will be copied to /etc/wpa_supplicant/ directory automatically once the Raspberry Pi is booted up. Enable SSH server. SSH access is disabled as default for security reasons. To enable the SSH server when Raspberry Pi is booted up for the first time: create a file called ssh with no file extension and no contents, and copy it to the /boot partition on the SD card. Find your raspberry on the network In order to find a raspberry pi over the network we can use commands like these: Linux ```shell= MY_IP_RANGE=$(ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}') nmap -sn MY_IP_RANGE IP= MY_IP_RANGE && IP= (arp -na | grep b8:27:eb | grep -Eo '[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}') ssh $IP; **Mac** (To be reviewed) ```shell= MY_RANGE=$(ip addr | grep UP -A3 | grep 192 -A0 | awk {print $2} ) nmap -sn $MY_RANGE arp -na | grep b8:27:eb SSH login without password: Si nunca has generado RSA key: ssh-keygen sin poner nada en la passphrase. Copiar la clave a la raspberry: ssh-copy-id -i ~/.ssh/id_rsa.pub raspi-address Ya que est\u00e9 lista la raspberry con conectarla debe bootear y conectarse sola a la red, el commando que esta arriba ( MY_IP... ) la localiza y hace ssh login. Once you are logged to your raspberry pi and connected to the internet, do a system upgrade : ```shell= sudo apt-get install rpi-update sudo rpi-update sudo apt-get update sudo apt-get dist-upgrade Install some **dependencies**: ```shell= sudo apt-get install git autoconf libtool make pkg-config libusb-1.0-0 libusb-1.0-0-dev telnet sshfs","title":"Debugger setup using a Raspberry Pi"},{"location":"Components/Firmware/guides/Debug the firmware/#openocd-installation","text":"Clon openocd repository and compile: shell=git clone git://git.code.sf.net/p/openocd/code openocd-codecd openocd-code./bootstrap./configure --enable-sysfsgpio --enable-bcm2835gpiomakesudo make install\u0002wzxhzdk:3\u0003You can store this file in OpenOCD scripts dir so it will auto find it shell= sudo mv sck.cfg /usr/local/share/openocd/scripts/ and then run the OpenOCD server with: ```shell= sudo openocd -f sck.cfg Then you can connect to OpenOCD, if you want to connect from an external computer, replace 127.0.0.1 with your Raspberry Pi IP address. shell=telnet 127.0.0.1 4444\u0002wzxhzdk:5\u0003Then you can connect to OpenOCD from your computer with: shell= telnet raspi_address 4444 ### Uploading Arduino original bootloader * Get the bootloader file [here](https://github.com/arduino/ArduinoCore-samd/tree/master/bootloaders/zero) and build it. * Connect to OpenOCD server and run: ```shell= reset halt at91samd bootloader 0 at91samd chip-erase program samd21_sam_ba.bin verify at91samd bootloader 8192 reset run If you don't see any error youre done!","title":"Openocd installation"},{"location":"Components/Firmware/guides/Debug the firmware/#uploading-sck-firmware","text":"Install platformio, download and build SCK firmware Connect to OpenOCD server and run: `shell=reset haltflash write_image firmware.bin 8192verify_image firmware.bin 8192reset runreset run","title":"Uploading SCK Firmware"},{"location":"Components/Firmware/guides/Debug the firmware/#gdb","text":"","title":"GDB"},{"location":"Components/Firmware/guides/Debug the firmware/#general-description","text":"The purpose of a debugger such as GDB is to allow you to see what is going on \u201cinside\u201d another program while it executes\u2014or what another program was doing at the moment it crashed. GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act: * Start your program, specifying anything that might affect its behavior. * Make your program stop on specified conditions. * Examine what has happened, when your program has stopped. * Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.","title":"General description"},{"location":"Components/Firmware/guides/Debug the firmware/#debugging-session-with-raspberry-pi-as-the-openocd-server","text":"Once your raspberry pi is setup with above instructions you can just do: ```shell= ssh pi@RaspberryAddress sudo openocd -f sck.cfg cd /platformio_project/path arm-none-eabi-gdb ./pioenvs/zeroUSB/firmware.elf (gdb) target remote RaspberryAddress:3333 (gdb) monitor reset run If you are using *platformio*, you need to modify the compiling option to avoid optimisation with -0g message to the compiler. In case you are not using *platformio*, activate verbose compiling output at Arduino IDE and find your compiled .elf directory. [env:zeroUSB] platform = atmelsam board = zeroUSB framework = arduino build_flags = -Og Now we are all set and ready to go. The debugger is waiting for instructions on the execution, which we detail below. !!! info **Quick handy instructions inside GDB environment** 1. *(gdb)* appears in every line and you don t have to type it each time 2. In case you need to exit GDB, just type in `quit`, but remember always killing the process before, should you have a target running ```shell= (gdb) kill (gdb) quit ``` 3. `RET` repeats the previous command ### GDB commands All commands in gdb during debugging are detailed in the GDB guide, chapter [GDB commands in detail (continue and stepping)](https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html) An **extract** of some useful commands are detailed below: #### Continuing and stepping `continue [ignore-count]` * Resumes program execution until next breakpoint. `[ignore-count]` argument allows to specify a further number of times to ingore a breakpoint. ```shell= (gdb) continue Continuing. Breakpoint 1, tick () at src/HOLA.cpp:9 9 void tick() { step count Continues running your program until control reaches a different source line , only availabe for source lines and functions compiled with debugging information. count is optional and states the number of steps to be performed before stopping, if no breakpoint arrives earlier. next [count] Continue to the next source line without going into functions . It has the same functionality as step, but it stays in the same stack frame. count works as in step count . As well, it understands jumps calls as in the end of for loops and return to the beginning of the loop. Info set step-mode on/off sets the behaviour of (gdb) when stepping into a function with no debugging information. In the case of step-mode on , it inspects the first line of code of the function, whereas on step-mode off it skips the function completely. finish Continue running until just after function in the selected stack frame returns . until Has the same behaviour as step , but it ignores the jumps between lines due to loops (for, whiles, etc), continuing to the next source code with incremental line number.","title":"Debugging session with Raspberry Pi as the OpenOCD server"},{"location":"Components/Firmware/guides/Debug the firmware/#breakpoints","text":"info breakpoints Retrieve information about breakpoints ```shell= (gdb) info breakpoints Num Type Disp Enb ress What 1 breakpoint keep y 0x00002140 in tick() at src/HOLA.cpp:9 breakpoint already hit 15 times `break` * Set a breakpoint in a specific function ```shell= (gdb) break loop Set a breakpoint in a specific line (344) ```shell= (gdb) break main.cpp:344 !!! info Use the **tbreak** command instead of break if you want to stop the program once, and then remove the breakpoint. More **breakpoint condition** options can be found [**here**](https://sourceware.org/gdb/current/onlinedocs/gdb/Conditions.html#Conditions) you can find `watchpoint` * Set a watchpoint [**watchpoint**](https://sourceware.org/gdb/current/onlinedocs/gdb/Set-Watchpoints.html#Set-Watchpoints) to only stop once a variable has a certain value. ```shell= (gdb) watch timer Info Type in info watchpoints to get information about watchpoints. commands Set a list of actions related to the breakpoint: ```shell= break main.cpp:50 commands silent printf \"count is %d\\n\",count cont end `delete` * Delete a breakpoint ```shell= (gdb) delete 1 (gdb) info breakpoints No breakpoints or watchpoints.","title":"Breakpoints"},{"location":"Components/Firmware/guides/Debug the firmware/#printing-setting-variables-and-more","text":"loop Read what is around a certain function ``shell=(gdb) l loop25 //while (!Serial) {26 //; // wait for serial port to connect. Needed for native USB port only27 //}28 }2930 void loop() {31 // put your main code here, to run repeatedly:32 Serial.println( HOLA );33 tick();34 Serial.println(millis());\u0002wzxhzdk:12\u0003 set` Set variable to a certain value ```shell= (gdb) set timer = 0 #### Target commands (load) `load filename offset` * `Load` it is meant to make filename (an executable) available for debugging on the remote system\u2014by downloading it. `load` also records the filename symbol table in GDB, like the add-symbol-file command. The file is loaded at whatever address is specified in the executable, also into flash memory. ### Making changes in the code Anytime we make a change in the code, we don t need to reload the debugging session. We can easily do so by: 1. Compile the code: a. Define Shell build in Sublime Text and configure a build sytem with: ``` shell_cmd : cd .. pio run ``` Then, everytime you hit Ctrl+B (Cmd+B) and you use your custom build system, it will automatically use this option. b. Or hit `pio run` in another terminal located in your project root directory 2. In gdb, `load` file. This will reload the file defined at the beginning of your debugging session and upload it to the target ```shell= (gdb) load Loading section .text, size 0x2e50 lma 0x2000 Loading section .ramfunc, size 0x60 lma 0x4e50 Loading section .data, size 0x110 lma 0x4eb0 Start address 0x2910, load size 12224 Transfer rate: 3 KB/sec, 4074 bytes/write. Keep debugging","title":"Printing / setting variables and more"},{"location":"Components/Firmware/guides/Debug the firmware/#gdb-console","text":"","title":"GDB Console"},{"location":"Components/Firmware/guides/Debug the firmware/#tui","text":"GDB has a console GUI option available with the command line option --tui In the upper frame you can see the code that's being executed.","title":"TUI"},{"location":"Components/Firmware/guides/Debug the firmware/#gdb-init-file","text":"From this example dashboard we can generate a custom .gdbinit file for the SCK which will be placed in the HOME directory... (ON GOING) Info Would be interesting to generate a custom option for production validation and one for internal debugging purposes For references about where to locate the .gdbinit and more custom behaviour for gdb in general see here .","title":"GDB init file"},{"location":"Components/Firmware/guides/Debug the firmware/#gdb-from-sublime-text","text":"Setup Platformio project with sublime Text Setup sublimeGDB","title":"GDB from Sublime Text"},{"location":"Components/Firmware/guides/Debug the firmware/#reference","text":"","title":"Reference"},{"location":"Components/Firmware/guides/Debug the firmware/#general-gdb-references-and-examples","text":"Debugging with GDB - Book Debugging example from GDB and OpenOCD Arduino zero example","title":"General GDB references and examples"},{"location":"Components/Firmware/guides/Debug the firmware/#additional-notes-from-platformio-configuration","text":"How to set other DEBUG FLAGS About project configuration with Platformio init Check here for building an *.ini file with custom build target for debugging and production.","title":"Additional notes from Platformio configuration"},{"location":"Components/Firmware/guides/Edit the Firmware/","text":"The data board of your Smartcitizen Kit is has two two microcontrollers : The main one is an Atmel SAMD21 , this chip is in charge of all the normal tasks like reading the sensors, saving data, interacting with the user, etc. For this chip we need two software components the bootloader and the main firmware. For communications the SCK has an ESP8266 microcontroler with Wifi capabilities , this chip receives instructions from the SAMD21 via serial port and takes care of publishing the collected data through the network. This chip needs a main firmware and a filesystem that stores the web pages for the setup mode server. Development enviroment Link The Smartcitizen Kit Firmware is on our repository on github so you will need git software installed . To build the Smartcitizen Kit firmware you need a linux computer with platformio installed, you don't need the full IDE installation (Atom). You can follow this instructions to install only the console version. For bootloader upload you also need OpenOCD somewhere in your PATH. You can use platformIO provided binary, normally it is located in ~/.platformio/packages/tool-openocd . Getting the firmware Link To get the firmware just run: git clone --recursive https://github.com/fablabbcn/smartcitizen-kit-20 The bootloader repository is a submodule of the main firmware so you must do a --recursive clone to get it. Info I you download manually (with the clone or download button on github) you will not get the bootloader code, but you can get it from here . SAMD21 bootloader Link If your kit doesn't have the bootloader already flashed (all the kits that we ship come with it) you will need an ATMEL-ICE programmer. This process can also be done with a Raspberry Pi computer and the proper connector and cables, we are preparing the documentation for this process. Connect the Atmel-ICE programmer to the 10 pin SWD connector and to your computer. Power the SCK via USB, you can use any USB charger or even your computer. Open a terminal, go to the folder where you cloned the firmware repository and run: cd smartcitizen-kit-20 ./build.sh boot If you have everything connected click any key to continue, you will see a lot of output when compiling, the led on the SCK should breath in green and you should see an output similar to this: You are ready for the next step, just remember to disconnect the Atmel-ICE programmer and connect the SCK to your computer with a USB cable. SAMD21 firmware Link The bootloader we just flashed allows a very simple way of uploading the SCK firmware based on the UF2 format, when you double-click the reset button of your kit it will expose a MSD interface to your computer and a new drive will popup where you can just drag the compiled firmware file (converted to UF2 format). Build script Link You can use the same script used to flash the bootloader ( build.sh ) that will do everything for you: compile the firmware, convert the binary to UF2 format and upload it to the kit: ./build.sh sam If you haven't already, double-click the reset button of your kit an click any key. If this is your first time building the software, platformio will take a while installing all the needed dependencies, be patient. If there are no errors you should see an output similar to this: The script will leave a copy of the compiled software in UF2 format called SAM_firmware.uf2 you can use this file to reflash your kit without compiling it again. Manual install Link If you want to install the firmware manually (or you had some problem with the build script) just follow this steps: cd sam pio run At the end you should see some output similar to this: then do: cd .. tools/uf2conv.py -o SAM_firmware.uf2 sam/.pioenvs/sck2/firmware.bin you should see: don't worry about the NO DEVICE WAS FLASHED message, we are doing it manually. Now double-click the reset button of your kit open your favorite file browser and drag the file you just created to the SCK-2.0 drive. The kit will reset and run the new firmware. Info Keep in mind that if your computer is not configured to automount new drives you will need to mount your sck manually ( as any other USB drive ). ESP8266 firmware Link Just like the other parts of the process this is also covered by our build.sh script. So you can just do: ./build.sh esp As before, if this is the first time you do it, it will take a while on downloading dependecies and building the firmware. In this case the upload process is different, since the ESP8266 chip is not connected to the USB interface the data must be uploadded through the SAMD21 chip. Our upload script takes care of searching for a SCK on the USB bus, sending a command to the kit so it put's himself in what we call bridge mode (white led) and uploading the firmware. This is the expected output: Info Sometimes the ESP8266 and the uploader software don't get synced and the upload fails. Normally if you try again it will work. ESP8266 filesystem Link This process is very similar to the previous one you just need to add the letters fs , and wait a little longer ;) ./build.sh espfs","title":"Edit the Firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#development-enviroment","text":"The Smartcitizen Kit Firmware is on our repository on github so you will need git software installed . To build the Smartcitizen Kit firmware you need a linux computer with platformio installed, you don't need the full IDE installation (Atom). You can follow this instructions to install only the console version. For bootloader upload you also need OpenOCD somewhere in your PATH. You can use platformIO provided binary, normally it is located in ~/.platformio/packages/tool-openocd .","title":"Development enviroment"},{"location":"Components/Firmware/guides/Edit the Firmware/#getting-the-firmware","text":"To get the firmware just run: git clone --recursive https://github.com/fablabbcn/smartcitizen-kit-20 The bootloader repository is a submodule of the main firmware so you must do a --recursive clone to get it. Info I you download manually (with the clone or download button on github) you will not get the bootloader code, but you can get it from here .","title":"Getting the firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#samd21-bootloader","text":"If your kit doesn't have the bootloader already flashed (all the kits that we ship come with it) you will need an ATMEL-ICE programmer. This process can also be done with a Raspberry Pi computer and the proper connector and cables, we are preparing the documentation for this process. Connect the Atmel-ICE programmer to the 10 pin SWD connector and to your computer. Power the SCK via USB, you can use any USB charger or even your computer. Open a terminal, go to the folder where you cloned the firmware repository and run: cd smartcitizen-kit-20 ./build.sh boot If you have everything connected click any key to continue, you will see a lot of output when compiling, the led on the SCK should breath in green and you should see an output similar to this: You are ready for the next step, just remember to disconnect the Atmel-ICE programmer and connect the SCK to your computer with a USB cable.","title":"SAMD21 bootloader"},{"location":"Components/Firmware/guides/Edit the Firmware/#samd21-firmware","text":"The bootloader we just flashed allows a very simple way of uploading the SCK firmware based on the UF2 format, when you double-click the reset button of your kit it will expose a MSD interface to your computer and a new drive will popup where you can just drag the compiled firmware file (converted to UF2 format).","title":"SAMD21 firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#build-script","text":"You can use the same script used to flash the bootloader ( build.sh ) that will do everything for you: compile the firmware, convert the binary to UF2 format and upload it to the kit: ./build.sh sam If you haven't already, double-click the reset button of your kit an click any key. If this is your first time building the software, platformio will take a while installing all the needed dependencies, be patient. If there are no errors you should see an output similar to this: The script will leave a copy of the compiled software in UF2 format called SAM_firmware.uf2 you can use this file to reflash your kit without compiling it again.","title":"Build script"},{"location":"Components/Firmware/guides/Edit the Firmware/#manual-install","text":"If you want to install the firmware manually (or you had some problem with the build script) just follow this steps: cd sam pio run At the end you should see some output similar to this: then do: cd .. tools/uf2conv.py -o SAM_firmware.uf2 sam/.pioenvs/sck2/firmware.bin you should see: don't worry about the NO DEVICE WAS FLASHED message, we are doing it manually. Now double-click the reset button of your kit open your favorite file browser and drag the file you just created to the SCK-2.0 drive. The kit will reset and run the new firmware. Info Keep in mind that if your computer is not configured to automount new drives you will need to mount your sck manually ( as any other USB drive ).","title":"Manual install"},{"location":"Components/Firmware/guides/Edit the Firmware/#esp8266-firmware","text":"Just like the other parts of the process this is also covered by our build.sh script. So you can just do: ./build.sh esp As before, if this is the first time you do it, it will take a while on downloading dependecies and building the firmware. In this case the upload process is different, since the ESP8266 chip is not connected to the USB interface the data must be uploadded through the SAMD21 chip. Our upload script takes care of searching for a SCK on the USB bus, sending a command to the kit so it put's himself in what we call bridge mode (white led) and uploading the firmware. This is the expected output: Info Sometimes the ESP8266 and the uploader software don't get synced and the upload fails. Normally if you try again it will work.","title":"ESP8266 firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#esp8266-filesystem","text":"This process is very similar to the previous one you just need to add the letters fs , and wait a little longer ;) ./build.sh espfs","title":"ESP8266 filesystem"},{"location":"Components/Firmware/guides/Update the firmware/","text":"When new features are developed or bugs are fixed we will release new versions of the SCK firmware. Updating your kit is very simple Connect your kit with a micro USB cable to your computer. Double click the reset button of your SCK, the SCK led should turn green and a new drive called SCK-20 should appear on your computer file browser. Inside the SCK-20 drive you should see some files, double click the INDEX.HTM file and our github releases page will open in your browser. Download the new firmware called SAM_firmware_XXX.uf2 and save it to your computer. Tip You can backup your current firmware version just saving the file called CURRENT.UF2 . Simply drag the firmware file you downloaded over the SCK-20 drive , your kit led will blink in green and after some seconds it will reset and start with the new version. After the update you just done, when your SCK gets connected to the network it will check for an updated versi\u00f3n of the wifi chip (ESP8266) firmware . If there is a new version your SCK will update automatically.","title":"Update the firmware"},{"location":"Components/Gas Pro Sensor Board/","text":"Gases Pro Sensor Board Link The Gases Sensor Board is a custom, ultra-low noise, high-performance, low power, digital output driver for 3 Alphasense Ltd. Electrochemical Series B Gas Sensors specifically designed for the project from the ground up. Check the source code Sensor measurements Link Measurement Units Sensor Carbon Monoxide ppm Alphasense CO-B4 Dioxide Nitrogen ppb Alphasense NO2-B43F Ozone ppb Alphasense OX-B431 Sensors selection Link The following characteristics have been considered for the sensor choice The driver's board designed includes a temperature and humidity sensor for calibrating the temperature dependence of the sensing subsystem. Same technology as the A4 series but more robust when exposed to outdoor environments 24/7. Designed for fixed site air quality networks which demand longer term reliability. Manufacturers provide the baseline resistance calibration values per sensor allowing corrections to be easily applied. Low power consumption The Alphasense EC Sensors were selected to provide a higher linearity, repeatability and resolution than the SGX MICS MO Gas Sensors found on the Urban Sensor Board. The final EC sensors selected were Alphasense Ltd. NO 2 B4 1 (Nitrogen Dioxide Sensor), O3B4 2 (Oxidising Gas Sensor Ozone + Nitrogen Dioxide) and COB4 3 (Carbon Monoxide). This selection was based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017 . Both (Penza and EuNetAir Consortium 2014) and (Mead et al. 2013) test the Alphasense Ltd (UK) NO 2 A1-A3 against reference instruments, both in the laboratory and in the field, with well-correlated results. The former concluded that the Data Quality Objective for \"indicative measurements\" (European Parliament and Council of the European Union, 2008) are fulfilled, and the latter report sensitivity in the low ppb region with high linearity. (Jensen 2016) (Spinelle et al. 2015) tested the Alphasense NO 2 B4 and O3B4 in a field experiment, with various calibration approaches. The correlation with reference measurements was poor (R2 \\ 0.1 and R2 \\ 0.5 for NO 2 and O 3 , respectively) when using linear and multivariate linear calibration, and good (R2 around 0.9 and 0.6 for NO 2 and O 3 , respectively) when using artificial neural networks. The poor results for NO 2 are likely due to the experiments being in a rural setting with quite low NO 2 concentrations. (Jensen 2016) . A performance evaluation of the same sensors was performed later including a test on a wide range of performance parameters (e.g. response time, calibration function, repeatability, drift, hysteresis effect and matrix effect) (Spinelle et al. 2015) . The experiment gave very good correlation with reference instruments (R2 > 0.99) and identifies some cases with major hysteresis effect related to humidity. (Spinelle et al. 2014) did a detailed laboratory and field study of the Alphasense Ltd (UK) O3B4 O 3 sensor, reporting good linearity, while uncertainty is adequately low to meet the requirements for \\\"indicative measurements\\\" by the Data Quality Objective (European Parliament and Council of the European Union, 2008). (Jensen 2016) . In chamber conditions, the performances of the Alphasense CO-B4 was found to be excellent, with the R2 values being greater than 0.99 (Castell et al. 2017; Mead et al. 2013; Sun et al. 2016 . However, the field investigations report significant deterioration and variations in sensor performances as given in Table 6. Two field studies reported moderate to excellent R2 values (0.53--0.97) for the CO-B4 sensor (Borrego et al. 2016) ; (Castell et al. 2017; Mead et al. 2013; Sun et al. 2016) . However, two other field studies have reported significantly lower R2 values (0.17--0.45) for the CO-B4, when calibrating them with reference measurements Castell et al. 2017; Mead et al. 2013; Sun et al. 2016) (Spinelle et al. 2017) (Rai et al. 2017) (Spinelle et al. 2017) . Design Link Each of the three drivers for Alphasense Ltd. Series B Sensors is built around the same design. They include a three stage adjustable amplifier design for the working electrode and and another simetrical design for the auxiliary electrode. Both signals are then feed to a high accuracy delta-sigma A/D converter with differential inputs 18 bits of resolution. All the parameters are digitally adjustable via I2C from the Data Board . Each board also include a unique identifier chip allowing the firmware on the Data Board to identify the board and apply the corresponding calibration values and a humidity and temperature sensor. Info Visit the source files section to download the complete schematics. Setup Link The board is connected to the Data Board using the AUX connector. Before, the Alphasense sensors need to be in place and properly registered using the board id. The board will be autodetected by the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image. Field validation Link Warning The following section is work in progress and the sensors are being test by different partners. A comparaison of the NO 2 measurements taken by the Gas Pro Board Alphasense NO2-B43F and a Teledyne TML-41 used by UCD as the reference equipment. Design Link Each of the three drivers for Alphasense Ltd. Series B Sensors is built around the same design. They include a three stage adjustable amplifier design for the working electrode and and another simetrical design for the auxiliary electrode. Both signals are then feed to a high accuracy delta-sigma A/D converter with differential inputs 18 bits of resolution. All the parameters are digitally adjustable via I2C from the Data Board . Each board also include a unique identifier chip allowing the firmware on the Data Board to identify the board and apply the corresponding calibration values and a humidity and temperature sensor. Info Visit the source files section to download the complete schematics. Setup Link The board is connected to the Data Board using the AUX connector. Before, the Alphasense sensors need to be in place and properly registered using the board id. The board will be autodetected by the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image. Field validation Link Warning The following section is work in progress and the sensors are being test by different partners. A comparaison of the NO2 measurements taken by the Gas Pro Board Alphasense NO2-B43F and a Teledyne TML-41 used by UCD as the reference equipment. Source files Link Download Check the source code ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf","title":"Index"},{"location":"Components/Gas Pro Sensor Board/#gases-pro-sensor-board","text":"The Gases Sensor Board is a custom, ultra-low noise, high-performance, low power, digital output driver for 3 Alphasense Ltd. Electrochemical Series B Gas Sensors specifically designed for the project from the ground up. Check the source code","title":"Gases Pro Sensor Board"},{"location":"Components/Gas Pro Sensor Board/#sensor-measurements","text":"Measurement Units Sensor Carbon Monoxide ppm Alphasense CO-B4 Dioxide Nitrogen ppb Alphasense NO2-B43F Ozone ppb Alphasense OX-B431","title":"Sensor measurements"},{"location":"Components/Gas Pro Sensor Board/#sensors-selection","text":"The following characteristics have been considered for the sensor choice The driver's board designed includes a temperature and humidity sensor for calibrating the temperature dependence of the sensing subsystem. Same technology as the A4 series but more robust when exposed to outdoor environments 24/7. Designed for fixed site air quality networks which demand longer term reliability. Manufacturers provide the baseline resistance calibration values per sensor allowing corrections to be easily applied. Low power consumption The Alphasense EC Sensors were selected to provide a higher linearity, repeatability and resolution than the SGX MICS MO Gas Sensors found on the Urban Sensor Board. The final EC sensors selected were Alphasense Ltd. NO 2 B4 1 (Nitrogen Dioxide Sensor), O3B4 2 (Oxidising Gas Sensor Ozone + Nitrogen Dioxide) and COB4 3 (Carbon Monoxide). This selection was based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017 . Both (Penza and EuNetAir Consortium 2014) and (Mead et al. 2013) test the Alphasense Ltd (UK) NO 2 A1-A3 against reference instruments, both in the laboratory and in the field, with well-correlated results. The former concluded that the Data Quality Objective for \"indicative measurements\" (European Parliament and Council of the European Union, 2008) are fulfilled, and the latter report sensitivity in the low ppb region with high linearity. (Jensen 2016) (Spinelle et al. 2015) tested the Alphasense NO 2 B4 and O3B4 in a field experiment, with various calibration approaches. The correlation with reference measurements was poor (R2 \\ 0.1 and R2 \\ 0.5 for NO 2 and O 3 , respectively) when using linear and multivariate linear calibration, and good (R2 around 0.9 and 0.6 for NO 2 and O 3 , respectively) when using artificial neural networks. The poor results for NO 2 are likely due to the experiments being in a rural setting with quite low NO 2 concentrations. (Jensen 2016) . A performance evaluation of the same sensors was performed later including a test on a wide range of performance parameters (e.g. response time, calibration function, repeatability, drift, hysteresis effect and matrix effect) (Spinelle et al. 2015) . The experiment gave very good correlation with reference instruments (R2 > 0.99) and identifies some cases with major hysteresis effect related to humidity. (Spinelle et al. 2014) did a detailed laboratory and field study of the Alphasense Ltd (UK) O3B4 O 3 sensor, reporting good linearity, while uncertainty is adequately low to meet the requirements for \\\"indicative measurements\\\" by the Data Quality Objective (European Parliament and Council of the European Union, 2008). (Jensen 2016) . In chamber conditions, the performances of the Alphasense CO-B4 was found to be excellent, with the R2 values being greater than 0.99 (Castell et al. 2017; Mead et al. 2013; Sun et al. 2016 . However, the field investigations report significant deterioration and variations in sensor performances as given in Table 6. Two field studies reported moderate to excellent R2 values (0.53--0.97) for the CO-B4 sensor (Borrego et al. 2016) ; (Castell et al. 2017; Mead et al. 2013; Sun et al. 2016) . However, two other field studies have reported significantly lower R2 values (0.17--0.45) for the CO-B4, when calibrating them with reference measurements Castell et al. 2017; Mead et al. 2013; Sun et al. 2016) (Spinelle et al. 2017) (Rai et al. 2017) (Spinelle et al. 2017) .","title":"Sensors selection"},{"location":"Components/Gas Pro Sensor Board/#design","text":"Each of the three drivers for Alphasense Ltd. Series B Sensors is built around the same design. They include a three stage adjustable amplifier design for the working electrode and and another simetrical design for the auxiliary electrode. Both signals are then feed to a high accuracy delta-sigma A/D converter with differential inputs 18 bits of resolution. All the parameters are digitally adjustable via I2C from the Data Board . Each board also include a unique identifier chip allowing the firmware on the Data Board to identify the board and apply the corresponding calibration values and a humidity and temperature sensor. Info Visit the source files section to download the complete schematics.","title":"Design"},{"location":"Components/Gas Pro Sensor Board/#setup","text":"The board is connected to the Data Board using the AUX connector. Before, the Alphasense sensors need to be in place and properly registered using the board id. The board will be autodetected by the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image.","title":"Setup"},{"location":"Components/Gas Pro Sensor Board/#field-validation","text":"Warning The following section is work in progress and the sensors are being test by different partners. A comparaison of the NO 2 measurements taken by the Gas Pro Board Alphasense NO2-B43F and a Teledyne TML-41 used by UCD as the reference equipment.","title":"Field validation"},{"location":"Components/Gas Pro Sensor Board/#design_1","text":"Each of the three drivers for Alphasense Ltd. Series B Sensors is built around the same design. They include a three stage adjustable amplifier design for the working electrode and and another simetrical design for the auxiliary electrode. Both signals are then feed to a high accuracy delta-sigma A/D converter with differential inputs 18 bits of resolution. All the parameters are digitally adjustable via I2C from the Data Board . Each board also include a unique identifier chip allowing the firmware on the Data Board to identify the board and apply the corresponding calibration values and a humidity and temperature sensor. Info Visit the source files section to download the complete schematics.","title":"Design"},{"location":"Components/Gas Pro Sensor Board/#setup_1","text":"The board is connected to the Data Board using the AUX connector. Before, the Alphasense sensors need to be in place and properly registered using the board id. The board will be autodetected by the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image.","title":"Setup"},{"location":"Components/Gas Pro Sensor Board/#field-validation_1","text":"Warning The following section is work in progress and the sensors are being test by different partners. A comparaison of the NO2 measurements taken by the Gas Pro Board Alphasense NO2-B43F and a Teledyne TML-41 used by UCD as the reference equipment.","title":"Field validation"},{"location":"Components/Gas Pro Sensor Board/#source-files","text":"Download Check the source code ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf","title":"Source files"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/","text":"Inside the Electrochemical Sensors Link Sensor working principle Link The electrochemical cells used are toxic gas sensors from alphasense that operate in an amperometric mode. That is, they generate a current that is linearly proportional to the fractional volume of the toxic gas in the environment: Image Source: Alphasense Ltd. These electrochemical sensors are comprised of four electrodes: Working electrode Auxiliary electrode Counter electrode Reference electrode The working electrode is where the oxidation (CO, H2S, NO, SO2) or reduction (NO 2 , Cl2) of the toxic gas to be measured takes place. This electrode is exposed to the outside air and directly exposed to all gases in the air including the gas to be measured. This electrode may as well be poisoned if it is exposed to certain gases that either adsorb onto the catalyst (such as acetylene onto CO sensors), or react, creating by-products which inhibit the catalyst (NO 2 or aromatics onto H2S sensors). The auxiliary electrode is an electrode of the same characteristics to those of the working electrode, but it is buried inside an electrolite and, hence, it is not in contact with the target gas. Since it is isolated from external conditions that could affect the working electrode , it serves as a reference to the measurements provided by the latter. The counter electrode balances the reaction of the working electrode \u2013 if the working electrode oxidises the gas, then the counter electrode must reduce some other molecule to generate an equivalent current, in the opposite sense. For example, where carbon monoxide will be oxidised on the working electrode, oxygen will be reduced on the counter electrode. The reference electrode anchors the working electrode potential to ensure that it is always working in the right conditions. It is important that the reference electrode has a stable potential, keeping the working electrode at the right electrochemical potential to maintain a constant sensitivity, good linearity and minimum sensitivity to interfering gases. Therefore, while the sensor response is exposed to the target gas, it creates a current flowing from the working to the counter electrode or viceversa (depending on the oxidative or reductive nature of the target gas). This relationship can be characterised and follows a curve such as: Image source: Alphasense Ltd. When operating in the so called transport limited current plateau the measured current (IL) should be linearly dependent on the concentration or fractional volume of the toxic gas (CT) in the external environment: I_L = k C_T I_L = k C_T where k is a proportionality constant. This constant is provided by the manufacturer as Sensitivity and is explained below. Electronics design considerations A potentiostat circuit is built in order to ensure that the counter electrode is provided with as much current as it needs, also maintaining the working electrode at a fixed potential, irrespective of how hard it is working. Manufacturer data Link The manufacturer provides the calibration data in laboratory conditions for each of the electrochemical cells used. This data is listed below: - Sensor sensitivity : the sensor response in nA per each ppm of target pollutant in nominal conditions - Electrode zero current : the electrode reading in nA to zero air (pure air at 25degC). This is provided for both, working and auxiliary electrodes, in the case of 4-electrode sensors - Sensor response ( t_{90} t_{90} ) - Sensor range The manufacturer suggests using the following equation in order to determine the sensor's corrected reading in the presence of target gas: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) With regards to sensor ranges , the following are available from the manufacture: NO 2 : 20ppm O3 + NO 2 : 20ppm both CO : 1000ppm Finally, toxic gas sensors' sensitivity will drift downwards with time, typically 0.5% to 2% per month , depending on the sensor type, relative humidity and gas concentration/temperature conditions. Reduction vs Oxidation Electrochemical Sensor Link As mentioned above, the counter electrode is meant to balance the reaction of the working electrode. This determines the current direction within the board: whether it goes from the working electrode to the counter electrode or viceversa. Oxidation sensors, such as CO, provoke a positive current out of the working electrode and the larger the amount of CO present, the larger (positive) is this current. Reduction sensors, such as NO 2 , provoke a negative current, i.e: going into the sensor and the larger the amount of NO 2 present, the larger (negative) is this current As an example, this is reflected in the different signs of the sensor sensitivity: NO2-B43F Average Batch Sensitivity: -347nA/ppm CO-B4F Average Batch Sensitivity: 588nA/ppm Although this is in principle directly related with the sensor itself, there are further signal transformations to be taken into account. For instance, the currents seen in the electrodes, if comparing between CO and NO 2 , should be different in sign, however, for both, CO and NO 2 sensors, we see positive currents which grow positively with higher CO and NO 2 concentrations: Hence, the sensor senstivity provided by the manufacturer should be considered in absolute terms ( abs(Sensitvity) abs(Sensitvity) ) for the calculations to yield always positive results in pollutant fractional volumes. Sensor Calibration Link The model described in the following section is based on the findings of 1 . This study uses alphasense's 3-electrode sensors, and here it is further extended to the case of 4-electrode sensors, taking into account the auxiliary electrode. Baseline correction based on temperature Link The mentioned work described the correction method based on temperature using a baseline correction algorithm which is described in 2 . This is summarised below: For each day of gas working electrode readings, and for each point in the time series (i), the minimum value of the working electrode value that is contained within the interval (i- \\delta \\delta i i+ \\delta \\delta ) is determined, where \\delta \\delta is an interval ranging from 0 to a day length. The outcome of this procedure is an array where each column is a vector of minimum working electrode values calculated for each \\delta_i \\delta_i value (this is, from now on, baseline_{\\delta_i} baseline_{\\delta_i} ). The correlation between each baseline_{\\delta_i} baseline_{\\delta_i} and the temperature is calculated. Relative humidity is not considered in this study since it's generaly inversely correlated with the temperature. The correlation coefficients for each correlation ( R^2_{\\delta_i} R^2_{\\delta_i} ) are calculated. The maximum R^2 R^2 whith this array is obtained. For the equation at which the maximum R^2_{\\delta_i} R^2_{\\delta_i} is found, the temperature reading is used to calculate the corrected baseline. The corrected baseline is substracted from the actual working electrode reading The final pollutant concentration is calculated based on the corrected working electrode reading and the manufacturer's data. The readings are treated in a day-to-day basis in order to avoid non-stationary temperature trends over several days, but still to account for temperature variations within each day. Finally, a background pollutant concentration is assumed from 3 which is also summarised below for each pollutant. This background concentration is added to the final result. Background concentrations . Source 3 Application on 4-electrode sensors Link This algorithm can be used to correct temperature effects on the working electrode based on the temperature in 4-electrode sensors. The results are discussed below for tests validation campaigns performed within the iScape project. These tests are summarized below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Living Lab Stations were deployed in two different sites, with two Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Living Lab Station was deployed with two Citizen kits. The results found with this methodology in the reduction sensors (NO 2 , O3) are significant in a daily basis. Two examples of the variation of the correlation coefficient with respect to the delta used to calculate the baseline are shown below: The algorithm is set to apply the best performing correlation function from either a linear or an exponential fit, basing this decission on the one that yields better correlation coefficient. NO 2 and O3 at high concentrations yield better results with an exponential fit, whilst lower concentrations reflect a linear trend: Furthermore, the study from which this methodology is drawn from states that oxidation sensors do not yield a proper baseline correlation methodology and so is validated. The result is indeed far better correlated with the reference measurement if using the manufacturer's methodology: This methodology reads as follows: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) In the case of NO 2 , the results provided by this baseline correction algorithm yield better results: Both, CO and NO 2 pollutants, using the best method for each calculation, are shown below: Finally, a comparison between the reference measurement results from both methods is detailed below: Manufacturer Method Baseline Method Pollutant RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 2 / 0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-9 / 0.1 - 0.3 As seen above, the NO 2 correlation with both methods yields significant results for non-corrected signals, whilst the RMSE values are higher in the case of the manufacturer's proposal. Therefore, for this pollutant, the selected methodology will be the baseline method. On the contrary, the CO measurements are highly uncorrelated with the baseline method, whilst the original manufacturer's proposal yields decent results. Finally, the O3 correlation levels are lower than the CO and NO 2 measurements. This is possibly due to the O3 reference measurement equipment used in the Bologna campaing, since it shows an inverse relationship with NO 2 which suggests a biased pollutant calculation in the reference equipment: As well, the results from UCD that are used as a reference for NO 2 , suggest a poor zero/span calibration of the equipment as it yields negative results that could spoil the NO 2 correlation/model errors from those tests: Baseline correction based on auxiliary electrode Link As seen above, the results from applying this methodology to a low concentration, urban environment measurement with 4-electrode sensors yield significantly correlated results in the case of the reductive sensors. It was also seen that oxidation measurements are significantly correlated with the reference measurements while using the manufacturer's suggested method. However, as detailed in the following section, the use of the auxiliary electrode as the source of the correction yields better results due to: The auxiliary electrode is accounting for both, temperature and absolute humidity. The latter could be discarded if the relative humidity is not considered. Since data is treated in a day to day basis, variations of mean temperatures during different days could provoke significant correlations to be found at different timelapses. This provokes gaps in the prediction during night hours that are reduced by the use of the auxiliary electrode. Finally, it is preferrably to use data contained in a single sensor (such as the auxiliary electrode for the EC sensor) rather than including additional sensors in the algorithm. A comparison between the results using this proposed method and the reference measurement from both test campaigns is seen below: Manufacturer Method Baseline Method With Temperature Baseline Method With Auxiliary Electrode Pollutant RMSE / R2 RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 2 / 0.1 2 / 0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6-12/0.1-0.4 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-12 / 0.2 4-9 / 0.1 - 0.3 References Link The use of electrochemical sensors for monitoring urban air quality in low-cost, high-density networks - M.I. Mead, O.A.M. Popoola, G.B. Stewart, P. Landshoff, M. Calleja, M. Hayesb, J.J. Baldovi, M.W. McLeod, T.F. Hodgson, J. Dicks, A. Lewis J. Cohen, R. Baron, J.R. Saffell, R.L. Jones Development of a baseline-temperature correction methodology for electrochemical sensors and its implications for long-term stability - Olalekan A.M. Popoola*, Gregor B. Stewart, Mohammed I. Mead, Roderic L. Jones Modelling atmospheric composition in urban street canyons - Vivien Bright, William Bloss and Xiaoming Cai","title":"Electrochemical Sensors"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#inside-the-electrochemical-sensors","text":"","title":"Inside the Electrochemical Sensors"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#sensor-working-principle","text":"The electrochemical cells used are toxic gas sensors from alphasense that operate in an amperometric mode. That is, they generate a current that is linearly proportional to the fractional volume of the toxic gas in the environment: Image Source: Alphasense Ltd. These electrochemical sensors are comprised of four electrodes: Working electrode Auxiliary electrode Counter electrode Reference electrode The working electrode is where the oxidation (CO, H2S, NO, SO2) or reduction (NO 2 , Cl2) of the toxic gas to be measured takes place. This electrode is exposed to the outside air and directly exposed to all gases in the air including the gas to be measured. This electrode may as well be poisoned if it is exposed to certain gases that either adsorb onto the catalyst (such as acetylene onto CO sensors), or react, creating by-products which inhibit the catalyst (NO 2 or aromatics onto H2S sensors). The auxiliary electrode is an electrode of the same characteristics to those of the working electrode, but it is buried inside an electrolite and, hence, it is not in contact with the target gas. Since it is isolated from external conditions that could affect the working electrode , it serves as a reference to the measurements provided by the latter. The counter electrode balances the reaction of the working electrode \u2013 if the working electrode oxidises the gas, then the counter electrode must reduce some other molecule to generate an equivalent current, in the opposite sense. For example, where carbon monoxide will be oxidised on the working electrode, oxygen will be reduced on the counter electrode. The reference electrode anchors the working electrode potential to ensure that it is always working in the right conditions. It is important that the reference electrode has a stable potential, keeping the working electrode at the right electrochemical potential to maintain a constant sensitivity, good linearity and minimum sensitivity to interfering gases. Therefore, while the sensor response is exposed to the target gas, it creates a current flowing from the working to the counter electrode or viceversa (depending on the oxidative or reductive nature of the target gas). This relationship can be characterised and follows a curve such as: Image source: Alphasense Ltd. When operating in the so called transport limited current plateau the measured current (IL) should be linearly dependent on the concentration or fractional volume of the toxic gas (CT) in the external environment: I_L = k C_T I_L = k C_T where k is a proportionality constant. This constant is provided by the manufacturer as Sensitivity and is explained below. Electronics design considerations A potentiostat circuit is built in order to ensure that the counter electrode is provided with as much current as it needs, also maintaining the working electrode at a fixed potential, irrespective of how hard it is working.","title":"Sensor working principle"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#manufacturer-data","text":"The manufacturer provides the calibration data in laboratory conditions for each of the electrochemical cells used. This data is listed below: - Sensor sensitivity : the sensor response in nA per each ppm of target pollutant in nominal conditions - Electrode zero current : the electrode reading in nA to zero air (pure air at 25degC). This is provided for both, working and auxiliary electrodes, in the case of 4-electrode sensors - Sensor response ( t_{90} t_{90} ) - Sensor range The manufacturer suggests using the following equation in order to determine the sensor's corrected reading in the presence of target gas: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) With regards to sensor ranges , the following are available from the manufacture: NO 2 : 20ppm O3 + NO 2 : 20ppm both CO : 1000ppm Finally, toxic gas sensors' sensitivity will drift downwards with time, typically 0.5% to 2% per month , depending on the sensor type, relative humidity and gas concentration/temperature conditions.","title":"Manufacturer data"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#reduction-vs-oxidation-electrochemical-sensor","text":"As mentioned above, the counter electrode is meant to balance the reaction of the working electrode. This determines the current direction within the board: whether it goes from the working electrode to the counter electrode or viceversa. Oxidation sensors, such as CO, provoke a positive current out of the working electrode and the larger the amount of CO present, the larger (positive) is this current. Reduction sensors, such as NO 2 , provoke a negative current, i.e: going into the sensor and the larger the amount of NO 2 present, the larger (negative) is this current As an example, this is reflected in the different signs of the sensor sensitivity: NO2-B43F Average Batch Sensitivity: -347nA/ppm CO-B4F Average Batch Sensitivity: 588nA/ppm Although this is in principle directly related with the sensor itself, there are further signal transformations to be taken into account. For instance, the currents seen in the electrodes, if comparing between CO and NO 2 , should be different in sign, however, for both, CO and NO 2 sensors, we see positive currents which grow positively with higher CO and NO 2 concentrations: Hence, the sensor senstivity provided by the manufacturer should be considered in absolute terms ( abs(Sensitvity) abs(Sensitvity) ) for the calculations to yield always positive results in pollutant fractional volumes.","title":"Reduction vs Oxidation Electrochemical Sensor"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#sensor-calibration","text":"The model described in the following section is based on the findings of 1 . This study uses alphasense's 3-electrode sensors, and here it is further extended to the case of 4-electrode sensors, taking into account the auxiliary electrode.","title":"Sensor Calibration"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#baseline-correction-based-on-temperature","text":"The mentioned work described the correction method based on temperature using a baseline correction algorithm which is described in 2 . This is summarised below: For each day of gas working electrode readings, and for each point in the time series (i), the minimum value of the working electrode value that is contained within the interval (i- \\delta \\delta i i+ \\delta \\delta ) is determined, where \\delta \\delta is an interval ranging from 0 to a day length. The outcome of this procedure is an array where each column is a vector of minimum working electrode values calculated for each \\delta_i \\delta_i value (this is, from now on, baseline_{\\delta_i} baseline_{\\delta_i} ). The correlation between each baseline_{\\delta_i} baseline_{\\delta_i} and the temperature is calculated. Relative humidity is not considered in this study since it's generaly inversely correlated with the temperature. The correlation coefficients for each correlation ( R^2_{\\delta_i} R^2_{\\delta_i} ) are calculated. The maximum R^2 R^2 whith this array is obtained. For the equation at which the maximum R^2_{\\delta_i} R^2_{\\delta_i} is found, the temperature reading is used to calculate the corrected baseline. The corrected baseline is substracted from the actual working electrode reading The final pollutant concentration is calculated based on the corrected working electrode reading and the manufacturer's data. The readings are treated in a day-to-day basis in order to avoid non-stationary temperature trends over several days, but still to account for temperature variations within each day. Finally, a background pollutant concentration is assumed from 3 which is also summarised below for each pollutant. This background concentration is added to the final result. Background concentrations . Source 3","title":"Baseline correction based on temperature"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#application-on-4-electrode-sensors","text":"This algorithm can be used to correct temperature effects on the working electrode based on the temperature in 4-electrode sensors. The results are discussed below for tests validation campaigns performed within the iScape project. These tests are summarized below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Living Lab Stations were deployed in two different sites, with two Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Living Lab Station was deployed with two Citizen kits. The results found with this methodology in the reduction sensors (NO 2 , O3) are significant in a daily basis. Two examples of the variation of the correlation coefficient with respect to the delta used to calculate the baseline are shown below: The algorithm is set to apply the best performing correlation function from either a linear or an exponential fit, basing this decission on the one that yields better correlation coefficient. NO 2 and O3 at high concentrations yield better results with an exponential fit, whilst lower concentrations reflect a linear trend: Furthermore, the study from which this methodology is drawn from states that oxidation sensors do not yield a proper baseline correlation methodology and so is validated. The result is indeed far better correlated with the reference measurement if using the manufacturer's methodology: This methodology reads as follows: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) In the case of NO 2 , the results provided by this baseline correction algorithm yield better results: Both, CO and NO 2 pollutants, using the best method for each calculation, are shown below: Finally, a comparison between the reference measurement results from both methods is detailed below: Manufacturer Method Baseline Method Pollutant RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 2 / 0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-9 / 0.1 - 0.3 As seen above, the NO 2 correlation with both methods yields significant results for non-corrected signals, whilst the RMSE values are higher in the case of the manufacturer's proposal. Therefore, for this pollutant, the selected methodology will be the baseline method. On the contrary, the CO measurements are highly uncorrelated with the baseline method, whilst the original manufacturer's proposal yields decent results. Finally, the O3 correlation levels are lower than the CO and NO 2 measurements. This is possibly due to the O3 reference measurement equipment used in the Bologna campaing, since it shows an inverse relationship with NO 2 which suggests a biased pollutant calculation in the reference equipment: As well, the results from UCD that are used as a reference for NO 2 , suggest a poor zero/span calibration of the equipment as it yields negative results that could spoil the NO 2 correlation/model errors from those tests:","title":"Application on 4-electrode sensors"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#baseline-correction-based-on-auxiliary-electrode","text":"As seen above, the results from applying this methodology to a low concentration, urban environment measurement with 4-electrode sensors yield significantly correlated results in the case of the reductive sensors. It was also seen that oxidation measurements are significantly correlated with the reference measurements while using the manufacturer's suggested method. However, as detailed in the following section, the use of the auxiliary electrode as the source of the correction yields better results due to: The auxiliary electrode is accounting for both, temperature and absolute humidity. The latter could be discarded if the relative humidity is not considered. Since data is treated in a day to day basis, variations of mean temperatures during different days could provoke significant correlations to be found at different timelapses. This provokes gaps in the prediction during night hours that are reduced by the use of the auxiliary electrode. Finally, it is preferrably to use data contained in a single sensor (such as the auxiliary electrode for the EC sensor) rather than including additional sensors in the algorithm. A comparison between the results using this proposed method and the reference measurement from both test campaigns is seen below: Manufacturer Method Baseline Method With Temperature Baseline Method With Auxiliary Electrode Pollutant RMSE / R2 RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 2 / 0.1 2 / 0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6-12/0.1-0.4 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-12 / 0.2 4-9 / 0.1 - 0.3","title":"Baseline correction based on auxiliary electrode"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#references","text":"The use of electrochemical sensors for monitoring urban air quality in low-cost, high-density networks - M.I. Mead, O.A.M. Popoola, G.B. Stewart, P. Landshoff, M. Calleja, M. Hayesb, J.J. Baldovi, M.W. McLeod, T.F. Hodgson, J. Dicks, A. Lewis J. Cohen, R. Baron, J.R. Saffell, R.L. Jones Development of a baseline-temperature correction methodology for electrochemical sensors and its implications for long-term stability - Olalekan A.M. Popoola*, Gregor B. Stewart, Mohammed I. Mead, Roderic L. Jones Modelling atmospheric composition in urban street canyons - Vivien Bright, William Bloss and Xiaoming Cai","title":"References"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/","text":"Advanced development setup Link How to use it? Link Connect the board The alphaDelta board should be connected to the kit auxiliary groove connector and the tester board to the alphaDelta. In this way the kit will have acces to both boards writing values in tester board and reading them in the sensor board. The tester board should be connected between Electrodes A and W from the slot you want to test. Get the firmware You will need the latest version of SCK 2.0 Firmware. To enable tester board in firmware uncomment #define deltaTest in sckAux.h file compile and upload the firmware. Read the sensors Link read Alphadelta [wichSensor: temperature, humidity, 1A, 2A, 2A, 2W, 3A, 3W] SCK read alphadelta 1a AlphaDelta 1A: 8.22 Control digital potentiometers Link control alphadelta 1A set pot [value: 0-100,000] SCK control alphadelta 1a set pot 50000 AlphaDelta 1A: set pot 50000 Setting pot to: 50000 Ohms Actual value: 49803 Ohms Run the tests Link The tester board is enabled as a control command of Alphasense Delta sensors, so it must be called with the prefix control then the name of the sensor alpha (fuzzy match is supported) then the test keyword followed by the slot number we want to test: control alpha test 1 To complete the line we should select one of the two test modes: set followed by a nA value between -1400/+1400. This will instruct the tester board to output that current and verify the readings of the sensor. control alpha test set SCK control alpha test 1 set 500 AlphaDelta 1A: test 1 set 500 Setting test current to: 500 Tester Electrode W: 500 Alphadelta 1W: 78.87 Tester Electrode A: 500 Alphadelta 1A: 78.70 Testing finished! or full that will ouput a csv formated table with the values for both electrodes of the selected slot from -1400 nA to 1400 nA: control alpha test 1 full SCK control alpha test 1 full AlphaDelta 1A: test 1 full testW,readW,testA,readA -1400,-220.94,-1400,-220.58 -1399,-220.92,-1399,-220.52 -1398,-220.78,-1398,-220.37 -1397,-220.62,-1397,-220.25 -1396,-220.48,-1396,-220.09 ... How to run the validation? Link For validating the boards, we propose verifying that: each nA input can only yield a single output in mV in the ADC, at minimum gain (for each electrode). This means that for a test such as: control alpha test 1 full We should obtain an always positively growing value in the readW, readA channels. For this, we have to check that: \\delta[n] = readX[n]-readX[n-1] 0 \\delta[n] = readX[n]-readX[n-1]>0 If we plot all this results we see that they are normally over 0.1 for all the boards, so we use this value as a minimum threshold, instead of zero: \\delta[n] = readX[n]-readX[n-1] 0.1 \\delta[n] = readX[n]-readX[n-1]>0.1 Finally, this test is also valid for too high gains since once the signal is saturated the \\delta \\delta value is 0 (saturates in a flat plateau). .embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }","title":"Advanced setup"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#advanced-development-setup","text":"","title":"Advanced development setup"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#how-to-use-it","text":"Connect the board The alphaDelta board should be connected to the kit auxiliary groove connector and the tester board to the alphaDelta. In this way the kit will have acces to both boards writing values in tester board and reading them in the sensor board. The tester board should be connected between Electrodes A and W from the slot you want to test. Get the firmware You will need the latest version of SCK 2.0 Firmware. To enable tester board in firmware uncomment #define deltaTest in sckAux.h file compile and upload the firmware.","title":"How to use it?"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#read-the-sensors","text":"read Alphadelta [wichSensor: temperature, humidity, 1A, 2A, 2A, 2W, 3A, 3W] SCK read alphadelta 1a AlphaDelta 1A: 8.22","title":"Read the sensors"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#control-digital-potentiometers","text":"control alphadelta 1A set pot [value: 0-100,000] SCK control alphadelta 1a set pot 50000 AlphaDelta 1A: set pot 50000 Setting pot to: 50000 Ohms Actual value: 49803 Ohms","title":"Control digital potentiometers"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#run-the-tests","text":"The tester board is enabled as a control command of Alphasense Delta sensors, so it must be called with the prefix control then the name of the sensor alpha (fuzzy match is supported) then the test keyword followed by the slot number we want to test: control alpha test 1 To complete the line we should select one of the two test modes: set followed by a nA value between -1400/+1400. This will instruct the tester board to output that current and verify the readings of the sensor. control alpha test set SCK control alpha test 1 set 500 AlphaDelta 1A: test 1 set 500 Setting test current to: 500 Tester Electrode W: 500 Alphadelta 1W: 78.87 Tester Electrode A: 500 Alphadelta 1A: 78.70 Testing finished! or full that will ouput a csv formated table with the values for both electrodes of the selected slot from -1400 nA to 1400 nA: control alpha test 1 full SCK control alpha test 1 full AlphaDelta 1A: test 1 full testW,readW,testA,readA -1400,-220.94,-1400,-220.58 -1399,-220.92,-1399,-220.52 -1398,-220.78,-1398,-220.37 -1397,-220.62,-1397,-220.25 -1396,-220.48,-1396,-220.09 ...","title":"Run the tests"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#how-to-run-the-validation","text":"For validating the boards, we propose verifying that: each nA input can only yield a single output in mV in the ADC, at minimum gain (for each electrode). This means that for a test such as: control alpha test 1 full We should obtain an always positively growing value in the readW, readA channels. For this, we have to check that: \\delta[n] = readX[n]-readX[n-1] 0 \\delta[n] = readX[n]-readX[n-1]>0 If we plot all this results we see that they are normally over 0.1 for all the boards, so we use this value as a minimum threshold, instead of zero: \\delta[n] = readX[n]-readX[n-1] 0.1 \\delta[n] = readX[n]-readX[n-1]>0.1 Finally, this test is also valid for too high gains since once the signal is saturated the \\delta \\delta value is 0 (saturates in a flat plateau). .embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }","title":"How to run the validation?"},{"location":"Components/PM Sensor Board/","text":"PM Sensor Board Link The PM Sensor Board is based around Plantower PMS 5003 1 a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. This includes a custom designed PCB with an MCU to provide I2C connectivity with the Data Board. Check the source code Sensor measurements Link Measurement Units Sensor PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM 10 \u00b5g/m3 Plantower PMS5003 Dual System Sensors selection Link The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 am No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power The selection is based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017) . Compliance with the NAAQS (US National Ambient Air Quality Standards) is based on 24-h PM mass concentrations [...] Both of the FEM instruments correlate with the 24-h PM2.5 mass measurements with an R2 > 0.99. The PMS PM2.5 concentrations are also well correlated with the 24-h mass average concentration (R2 > 0.88), which is slightly better than the GRIMM research-grade instrument (R2 1\u20444 0.7.). South Coast Air Quality Management District (SCAQMD) recently published preliminary comparisons of the PM2.5 measurements from three PMS 1003s and two FEMs, with high correlations (R2 > 0.9) over a 2-month period. This study demonstrated that the PMS 1003/3003 correlates well with FRMs, FEMs, and research-grade instrumentation under ambient conditions during a series of cold-air pools and in a wind-tunnel environment. Under ambient conditions, this sensor correlates better with an FRM than other low-cost sensors in similar studies. [...] these sensors are a promising tool for identifying relative increases or decreases in PM concentration, complementing sparsely distributed monitoring stations and for assessing and minimizing exposure to PM (Kelly et al. 2017) . Design Link The PM Sensor Board runs a dedicated ARM M0+ 32-bits, the same as the Data Board to provide a unified hardware architecture. The board includes an higly efficient step up to provide 5V to drive the PM sensors and a disable/enable circuit to turn off the sensor by software. Info Visit the source files section to download the complete schematics. Setup Link The board is connected to the Data Board using the AUX connector. Before, the Plantower PMS sensors need to be connected. The board will autodetect the PMS sensors and present them seamlessly to the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image. Source files Link Download Check the source code PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf","title":"Index"},{"location":"Components/PM Sensor Board/#pm-sensor-board","text":"The PM Sensor Board is based around Plantower PMS 5003 1 a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. This includes a custom designed PCB with an MCU to provide I2C connectivity with the Data Board. Check the source code","title":"PM Sensor Board"},{"location":"Components/PM Sensor Board/#sensor-measurements","text":"Measurement Units Sensor PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM 10 \u00b5g/m3 Plantower PMS5003 Dual System","title":"Sensor measurements"},{"location":"Components/PM Sensor Board/#sensors-selection","text":"The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 am No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power The selection is based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017) . Compliance with the NAAQS (US National Ambient Air Quality Standards) is based on 24-h PM mass concentrations [...] Both of the FEM instruments correlate with the 24-h PM2.5 mass measurements with an R2 > 0.99. The PMS PM2.5 concentrations are also well correlated with the 24-h mass average concentration (R2 > 0.88), which is slightly better than the GRIMM research-grade instrument (R2 1\u20444 0.7.). South Coast Air Quality Management District (SCAQMD) recently published preliminary comparisons of the PM2.5 measurements from three PMS 1003s and two FEMs, with high correlations (R2 > 0.9) over a 2-month period. This study demonstrated that the PMS 1003/3003 correlates well with FRMs, FEMs, and research-grade instrumentation under ambient conditions during a series of cold-air pools and in a wind-tunnel environment. Under ambient conditions, this sensor correlates better with an FRM than other low-cost sensors in similar studies. [...] these sensors are a promising tool for identifying relative increases or decreases in PM concentration, complementing sparsely distributed monitoring stations and for assessing and minimizing exposure to PM (Kelly et al. 2017) .","title":"Sensors selection"},{"location":"Components/PM Sensor Board/#design","text":"The PM Sensor Board runs a dedicated ARM M0+ 32-bits, the same as the Data Board to provide a unified hardware architecture. The board includes an higly efficient step up to provide 5V to drive the PM sensors and a disable/enable circuit to turn off the sensor by software. Info Visit the source files section to download the complete schematics.","title":"Design"},{"location":"Components/PM Sensor Board/#setup","text":"The board is connected to the Data Board using the AUX connector. Before, the Plantower PMS sensors need to be connected. The board will autodetect the PMS sensors and present them seamlessly to the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image.","title":"Setup"},{"location":"Components/PM Sensor Board/#source-files","text":"Download Check the source code PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf","title":"Source files"},{"location":"Components/PM Sensor Board/Plantower PMS/","text":"Plantower PMS Link Pulse mode correlation Link The purpose of this test is to determine the time needed to obtain representative readings in a one-shot mode. For this, two kits V2.0 are used with several PM Boards and one PMS5003 connected to each of them: KIT1: Named OSCAR + 1xPMS5003 KIT2: Named TEST7 + 1xPMS5003 One of them is set in a continuous operation mode, while the other operates in on/off mode with different on-times. TEST : - 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE - 2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE Results Link 2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE 30min logging with a candle under the sensors. Initial 3min in stabilised conditions: 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE 30min logging with normal ambient air. Initial 3min in stabilised conditions Target errors Link The initial 3min are used to determine target errors on the stabilisation phase. For each dataset, they are below: High PN Average Std Deviation Relative_error_PM 1.0 0.15 0.17 Relative_error_PM 2.5 -0.02 0.16 Relative_error_PM 10.0 -0.10 0.20 Low PN Average Std Deviation Relative_error_PM 1.0 0.07 0.07 Relative_error_PM 2.5 0.01 0.07 Relative_error_PM 10.0 0.04 0.08 Measurement iterations Link The measurement iterations are plotted below, versus the wake up time: Assuming a confidence interval of 95%, the target value for the measurement mean is (\\mu - \\sigma \\mu \\mu + \\sigma) (\\mu - \\sigma<\\mu<\\mu + \\sigma) and the values for each period are extracted from the plots above: Target Time Low PN High PN PM 1.0 15s 4s PM 2.5 15s 5s PM 10.0 12s 5s Conclusion Link Although the PMS has a faster response at high PN, the variability and the measurement averages are higher as well. This can also be due to the measurement method uncertainty For low PN, the time required for stabilisation is between 12 and 15s, to achieve a level of 95% confidence with respect to that of stabilised levels The target time should be 15s, although lower values could be considered down to 12s if there are battery concerns PMS Family correlation tests Link Tests were conducted over two weeks in Barcelona in order to compare both, PlanTower PMS7003 and PMS5003. Results are shown before for normal urban environment levels of exposure: Average Level RMSE R2 PM 1.0 13.89 2.34 0.90 PM 2.5 19.40 3.78 0.88 PM 10.0 20.49 0.85 4.43 Power consumption tests Link PMS7003 Link Datasheet ![]( https://i.imgur.com/rfQGDPW.jpg =400x) (Check the adaptor position) Power consumption Power consumption is around 50mA in average with peaks of 100mA PMS5003 Link ![]( https://i.imgur.com/i0CXOm8.jpg =400x) Power consumption Power consumption is around 50mA in average with peaks of 94mA","title":"Plantower PMS"},{"location":"Components/PM Sensor Board/Plantower PMS/#plantower-pms","text":"","title":"Plantower PMS"},{"location":"Components/PM Sensor Board/Plantower PMS/#pulse-mode-correlation","text":"The purpose of this test is to determine the time needed to obtain representative readings in a one-shot mode. For this, two kits V2.0 are used with several PM Boards and one PMS5003 connected to each of them: KIT1: Named OSCAR + 1xPMS5003 KIT2: Named TEST7 + 1xPMS5003 One of them is set in a continuous operation mode, while the other operates in on/off mode with different on-times. TEST : - 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE - 2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE","title":"Pulse mode correlation"},{"location":"Components/PM Sensor Board/Plantower PMS/#results","text":"2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE 30min logging with a candle under the sensors. Initial 3min in stabilised conditions: 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE 30min logging with normal ambient air. Initial 3min in stabilised conditions","title":"Results"},{"location":"Components/PM Sensor Board/Plantower PMS/#target-errors","text":"The initial 3min are used to determine target errors on the stabilisation phase. For each dataset, they are below: High PN Average Std Deviation Relative_error_PM 1.0 0.15 0.17 Relative_error_PM 2.5 -0.02 0.16 Relative_error_PM 10.0 -0.10 0.20 Low PN Average Std Deviation Relative_error_PM 1.0 0.07 0.07 Relative_error_PM 2.5 0.01 0.07 Relative_error_PM 10.0 0.04 0.08","title":"Target errors"},{"location":"Components/PM Sensor Board/Plantower PMS/#measurement-iterations","text":"The measurement iterations are plotted below, versus the wake up time: Assuming a confidence interval of 95%, the target value for the measurement mean is (\\mu - \\sigma \\mu \\mu + \\sigma) (\\mu - \\sigma<\\mu<\\mu + \\sigma) and the values for each period are extracted from the plots above: Target Time Low PN High PN PM 1.0 15s 4s PM 2.5 15s 5s PM 10.0 12s 5s","title":"Measurement iterations"},{"location":"Components/PM Sensor Board/Plantower PMS/#conclusion","text":"Although the PMS has a faster response at high PN, the variability and the measurement averages are higher as well. This can also be due to the measurement method uncertainty For low PN, the time required for stabilisation is between 12 and 15s, to achieve a level of 95% confidence with respect to that of stabilised levels The target time should be 15s, although lower values could be considered down to 12s if there are battery concerns","title":"Conclusion"},{"location":"Components/PM Sensor Board/Plantower PMS/#pms-family-correlation-tests","text":"Tests were conducted over two weeks in Barcelona in order to compare both, PlanTower PMS7003 and PMS5003. Results are shown before for normal urban environment levels of exposure: Average Level RMSE R2 PM 1.0 13.89 2.34 0.90 PM 2.5 19.40 3.78 0.88 PM 10.0 20.49 0.85 4.43","title":"PMS Family correlation tests"},{"location":"Components/PM Sensor Board/Plantower PMS/#power-consumption-tests","text":"","title":"Power consumption tests"},{"location":"Components/PM Sensor Board/Plantower PMS/#pms7003","text":"Datasheet ![]( https://i.imgur.com/rfQGDPW.jpg =400x) (Check the adaptor position) Power consumption Power consumption is around 50mA in average with peaks of 100mA","title":"PMS7003"},{"location":"Components/PM Sensor Board/Plantower PMS/#pms5003","text":"![]( https://i.imgur.com/i0CXOm8.jpg =400x) Power consumption Power consumption is around 50mA in average with peaks of 94mA","title":"PMS5003"},{"location":"Components/Urban Sensor Board/","text":"Urban Sensor Board Link The Urban Sensor Board contains a selection of sensors for the measuring the urban outdoor environment. The sensor selection is based on the recommendations provided by ISCAPE WP1 among the experience acquired from previous Smart Citizen Kit generations. Check the source code A major effort has been carried out on this design to improve the accuracy of the data provided. The sensors on the board include: Air Temperature, Relative Humidity, Noise Level, Ambient Light and Barometric Pressure. The board also features a section especially focused on Air Quality including a Particles Matter, a Carbon Monoxide and a Dioxide Nitrogen detectors. The sensor density of the board design offers more than ten different environmental metrics at a cost below 50\u20ac and differentiates the design from other existing solutions. The following sections describe in detail each of the sensors available. Board assembly The Urban Sensor Board connect to the Data Board connector named Sensor Board Measurement Units Sensor Air Temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise Level dBA, dBC, dBZ Invensense ICS-434342 Ambient Light Lux Rohm BH1721FVC Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Carbon Monoxide ppm (Periodic Baseline Calibration Required) SGX MICS-4514 Dioxide Nitrogen ppb (Periodic Baseline Calibration Required) SGX MICS-4514 Particle Matter PM2.5 (external - power req) \u00b5g/m3 PMS 7003 Metal Oxide NO 2 and CO Sensor Link The SGX Sensortech (formerly e2v) MICS 4514 1 is a dual, robust MEMS sensor for the detection of pollution from automobile exhausts. It integrates on a single SMD package the more well-known SGX MICS 5525 for Carbon Monoxide detection and the SGX MICS 2710 for Dioxide Nitrogen detection. The sensor includes two sensor chips with independent heaters and sensitive layers. One sensor chip detects Oxidizing gases (OX) primarily NO 2 in a 0.05-10ppm, and the other sensor detects reducing gases (RED) primarily NO 2 in a 1-1000ppm. The following characteristics have been considered for the sensor choice: Combines in the same package both the CO and NO 2 sensors in a low-cost unit \\ 15\u20ac Low heating current, especially important since the sensor can be battery-powered. Wide range gas concentration detection. Extensive operational temperature range. Robust to vibrations and shocks. The MICS-4514 Carbon Monoxide detection performance was tested by (Rai et al. 2017; Spinelle et al. 2017) under field conditions. They reported good agreement (R2 = 0.76--0.78) between sensor response and reference measurements when it was calibrated by using simple or multiple linear regression models (Rai et al. 2017) The sensor integration on the Urban Sensor Board features an analog front-end different than those used by other products using the same sensor to achieve more precise and stable readings. That includes a dynamic gaining circuit and an adjustable heating system designed from the ground up for this application. However, the baseline resistance can vary a lot from sensor to sensor, and according to the measuring conditions, which is why the manufacturer recommends monitoring the sensitivity periodically. That mean re-calibration of the device after a few months might be required because the pairs of metal-oxide on the surface of the captor change their physical properties when exposed to the detectable gases. That is the primary reason the Living Lab Station include an extra Gas Sensor Board featuring three pre calibrated EC gas sensors to provide more precise and meaningful air quality data. Sensor integration Main Sensor Interface Filters Analog to Digital Converter Digital Potentiometer for heater control Heater design Check the MICS implementation document to learn more about the brand new heating stage. Field validation The NO 2 data the sensor post processed with the Sensor Analysis Framework compared with the Arpae Emilia-Romagna referenced instrumentation. Read more More on the MICS working principle and field validation Noise Level Sensor Link The noise sensor is based on the INVENSENSE ICS-43432 2 high-performance, low power, digital output, omnidirectional MEMS microphone with a bottom port and I2S interface. The sensors are similar to the one found on some high-end smartphones. It delivers the information directly in a digital format to the MCU where a custom library has been developed to provide noise data in dB scales A, C and Z. The raw FFT is also accessible to support characterization of specific noise frequencies. The sensor has been calibrated specifically for the project on an anechoic chamber using standard microphone calibration procedures. The following characteristics have been considered for the sensor choice High 65 dBA SNR with a \u221226 dB FS Sensitivity Low Sensitivity Tolerance \u00b11 dB Wide Frequency Response from 50Hz to 20kHz High Acoustic Overload Point 116 dB SPL Low Power Info Check the Noise sensor implementation full documentation Sensor integration Relative Humidity and Air Temperature Sensor Link Relative Humidity and Air Temperature Sensor are provided by a SENSIRION SHT31 3 module. Sensor upgrade Preliminary tests during the project shown a absolute calibration issues affecting the previously selected sensor, the SENSIRION SHT31. Those we updated the sensor to the newest SHT 31 with a PTFE layer for protection obtaining better results. The following characteristics have been considered for the sensor choice Calibrated, linearized sensor signals in digital, I2C format straight to the MCU where data is provided in degrees Celsius and Relative Humidity. Wide measurement range with high resolution. The relative humidity range of 0-100% RH with a 0.03% resolution and a repeatability of 0.1%, together with a temperature operating range from -40 to +125\u00b0C with a temperature resolution of 0.01 \u00baC and a repeatability of 0.1%. No need for calibration and long-term stability. Low power consumption Commonly found in many commercial weather stations as the Davis Vantage Pro. Sensor integration Ambient Light Sensor Link The Ambient Light Sensors is based around the ROHM BH1721FVC 4 which uses an LDR10 combined with an ADC and the corresponding circuit that allows communicating with the device with the I2C protocol. The following characteristics have been considered for the sensor choice: No need of external ADC or linearization circuits uses the well-known I2C protocol Measures ambient light data in a wide range from 1lx to 65528 lx a repeatability of 15% and a resolution of 8 lx. Possibility to adjust by an I2C command the kind of light that it should measure (visible or infrared). The infrared channel is not used in the current version, but it could be considered in future versions. Low power consumption. 50Hz/60Hz (electric network frequency) light rejection. Filtering the interference of most artificial light sources. Sensor integration Barometric Pressure Link The Barometric Pressure sensor is based around the NXP MPL3115A2 5 is a compact, piezoresistive, absolute pressure sensor with an I2C digital interface. The following characteristics have been considered for the sensor choice: Wide operating range of 20 kPa to 110 kPa. Temperature compensated utilizing an on-chip temperature sensor. No need for an external ADC or linearization circuits. The pressure and temperature data is fed into an internal high-resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C using the well-known I2C protocol Barometric pressure is also processed by the MCU as height above mean sea level (AMSL) helping to determine the location of the device. Low power consumption. Sensor integration Dust Particles Sensor Link Warning The following sensor might be replaced in future iterations as it gets replaced by the External PM Sensor connector supporting a Plantowe PMS5003 or PMS7003 The MAXIM MAX30105 6 is an integrated particle-sensing module. Is a high Sensitivity Optical Reflective Solution for detection of wide\u2029a variety of particle sizes. This sensor is aimed at measuring relative air dust levels. However, an algorithm is being developed to support PM 2.5 or PM 10 measurements. At the time the document is being written no data on the sensor lab tests can be provided. The following characteristics have been considered for the sensor choice: No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. Robust Motion Artifact Resilience and -40\u00b0C to +85\u00b0C Operating Temperature Capable of Operating at High Ambient Levels with Excellent Ambient Rejection Capability Includes a temperature sensor for calibrating the temperature dependence of the particle sensing subsystem. Low power consumption Sensor integration External PM Sensor Link An external connector on the board supports the connection of a Plantower PMS 5003 or PMS 7003 10 . The device is a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. The sensor can be fully enable or disable in software to save energy when not in use. The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 am No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power The selection is based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017) . Compliance with the NAAQS (US National Ambient Air Quality Standards) is based on 24-h PM mass concentrations [...] Both of the FEM instruments correlate with the 24-h PM2.5 mass measurements with an R2 > 0.99. The PMS PM2.5 concentrations are also well correlated with the 24-h mass average concentration (R2 > 0.88), which is slightly better than the GRIMM research-grade instrument (R2 1\u20444 0.7.). South Coast Air Quality Management District (SCAQMD) recently published preliminary comparisons of the PM2.5 measurements from three PMS 1003s and two FEMs, with high correlations (R2 > 0.9) over a 2-month period. This study demonstrated that the PMS 1003/3003 correlates well with FRMs, FEMs, and research-grade instrumentation under ambient conditions during a series of cold-air pools and in a wind-tunnel environment. Under ambient conditions, this sensor correlates better with an FRM than other low-cost sensors in similar studies. [...] these sensors are a promising tool for identifying relative increases or decreases in PM concentration, complementing sparsely distributed monitoring stations and for assessing and minimizing exposure to PM (Kelly et al. 2017) . Sensor integration Source files Link Download Check the source code SGX MICS 4514 Technical Datasheet https://sgx.cdistore.com/datasheets/sgx/0278_Datasheet%20MiCS-4514%20rev%2017.pdf INVENSENSE 43432 Technical Datasheet https://www.invensense.com/wp-content/uploads/2015/02/ICS-43432-data-sheet-v1.3.pdf SENSIRION SHT31 Technical Datasheet https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/2_Humidity_Sensors/ ROHM BH1730 Technical Datasheet http://rohmfs.rohm.com/en/products/databook/datasheet/ic/sensor/light/bh1721fvc-e.pdf NXP MPL3115A2 Technical Datasheet http://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf MAXIM 30105 Technical Datasheet https://datasheets.maximintegrated.com/en/ds/MAX30105.pdf ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf","title":"Index"},{"location":"Components/Urban Sensor Board/#urban-sensor-board","text":"The Urban Sensor Board contains a selection of sensors for the measuring the urban outdoor environment. The sensor selection is based on the recommendations provided by ISCAPE WP1 among the experience acquired from previous Smart Citizen Kit generations. Check the source code A major effort has been carried out on this design to improve the accuracy of the data provided. The sensors on the board include: Air Temperature, Relative Humidity, Noise Level, Ambient Light and Barometric Pressure. The board also features a section especially focused on Air Quality including a Particles Matter, a Carbon Monoxide and a Dioxide Nitrogen detectors. The sensor density of the board design offers more than ten different environmental metrics at a cost below 50\u20ac and differentiates the design from other existing solutions. The following sections describe in detail each of the sensors available. Board assembly The Urban Sensor Board connect to the Data Board connector named Sensor Board Measurement Units Sensor Air Temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise Level dBA, dBC, dBZ Invensense ICS-434342 Ambient Light Lux Rohm BH1721FVC Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Carbon Monoxide ppm (Periodic Baseline Calibration Required) SGX MICS-4514 Dioxide Nitrogen ppb (Periodic Baseline Calibration Required) SGX MICS-4514 Particle Matter PM2.5 (external - power req) \u00b5g/m3 PMS 7003","title":"Urban Sensor Board"},{"location":"Components/Urban Sensor Board/#metal-oxide-no2-and-co-sensor","text":"The SGX Sensortech (formerly e2v) MICS 4514 1 is a dual, robust MEMS sensor for the detection of pollution from automobile exhausts. It integrates on a single SMD package the more well-known SGX MICS 5525 for Carbon Monoxide detection and the SGX MICS 2710 for Dioxide Nitrogen detection. The sensor includes two sensor chips with independent heaters and sensitive layers. One sensor chip detects Oxidizing gases (OX) primarily NO 2 in a 0.05-10ppm, and the other sensor detects reducing gases (RED) primarily NO 2 in a 1-1000ppm. The following characteristics have been considered for the sensor choice: Combines in the same package both the CO and NO 2 sensors in a low-cost unit \\ 15\u20ac Low heating current, especially important since the sensor can be battery-powered. Wide range gas concentration detection. Extensive operational temperature range. Robust to vibrations and shocks. The MICS-4514 Carbon Monoxide detection performance was tested by (Rai et al. 2017; Spinelle et al. 2017) under field conditions. They reported good agreement (R2 = 0.76--0.78) between sensor response and reference measurements when it was calibrated by using simple or multiple linear regression models (Rai et al. 2017) The sensor integration on the Urban Sensor Board features an analog front-end different than those used by other products using the same sensor to achieve more precise and stable readings. That includes a dynamic gaining circuit and an adjustable heating system designed from the ground up for this application. However, the baseline resistance can vary a lot from sensor to sensor, and according to the measuring conditions, which is why the manufacturer recommends monitoring the sensitivity periodically. That mean re-calibration of the device after a few months might be required because the pairs of metal-oxide on the surface of the captor change their physical properties when exposed to the detectable gases. That is the primary reason the Living Lab Station include an extra Gas Sensor Board featuring three pre calibrated EC gas sensors to provide more precise and meaningful air quality data. Sensor integration Main Sensor Interface Filters Analog to Digital Converter Digital Potentiometer for heater control Heater design Check the MICS implementation document to learn more about the brand new heating stage. Field validation The NO 2 data the sensor post processed with the Sensor Analysis Framework compared with the Arpae Emilia-Romagna referenced instrumentation. Read more More on the MICS working principle and field validation","title":"Metal Oxide NO2 and CO Sensor"},{"location":"Components/Urban Sensor Board/#noise-level-sensor","text":"The noise sensor is based on the INVENSENSE ICS-43432 2 high-performance, low power, digital output, omnidirectional MEMS microphone with a bottom port and I2S interface. The sensors are similar to the one found on some high-end smartphones. It delivers the information directly in a digital format to the MCU where a custom library has been developed to provide noise data in dB scales A, C and Z. The raw FFT is also accessible to support characterization of specific noise frequencies. The sensor has been calibrated specifically for the project on an anechoic chamber using standard microphone calibration procedures. The following characteristics have been considered for the sensor choice High 65 dBA SNR with a \u221226 dB FS Sensitivity Low Sensitivity Tolerance \u00b11 dB Wide Frequency Response from 50Hz to 20kHz High Acoustic Overload Point 116 dB SPL Low Power Info Check the Noise sensor implementation full documentation Sensor integration","title":"Noise Level Sensor"},{"location":"Components/Urban Sensor Board/#relative-humidity-and-air-temperature-sensor","text":"Relative Humidity and Air Temperature Sensor are provided by a SENSIRION SHT31 3 module. Sensor upgrade Preliminary tests during the project shown a absolute calibration issues affecting the previously selected sensor, the SENSIRION SHT31. Those we updated the sensor to the newest SHT 31 with a PTFE layer for protection obtaining better results. The following characteristics have been considered for the sensor choice Calibrated, linearized sensor signals in digital, I2C format straight to the MCU where data is provided in degrees Celsius and Relative Humidity. Wide measurement range with high resolution. The relative humidity range of 0-100% RH with a 0.03% resolution and a repeatability of 0.1%, together with a temperature operating range from -40 to +125\u00b0C with a temperature resolution of 0.01 \u00baC and a repeatability of 0.1%. No need for calibration and long-term stability. Low power consumption Commonly found in many commercial weather stations as the Davis Vantage Pro. Sensor integration","title":"Relative Humidity and Air Temperature Sensor"},{"location":"Components/Urban Sensor Board/#ambient-light-sensor","text":"The Ambient Light Sensors is based around the ROHM BH1721FVC 4 which uses an LDR10 combined with an ADC and the corresponding circuit that allows communicating with the device with the I2C protocol. The following characteristics have been considered for the sensor choice: No need of external ADC or linearization circuits uses the well-known I2C protocol Measures ambient light data in a wide range from 1lx to 65528 lx a repeatability of 15% and a resolution of 8 lx. Possibility to adjust by an I2C command the kind of light that it should measure (visible or infrared). The infrared channel is not used in the current version, but it could be considered in future versions. Low power consumption. 50Hz/60Hz (electric network frequency) light rejection. Filtering the interference of most artificial light sources. Sensor integration","title":"Ambient Light Sensor"},{"location":"Components/Urban Sensor Board/#barometric-pressure","text":"The Barometric Pressure sensor is based around the NXP MPL3115A2 5 is a compact, piezoresistive, absolute pressure sensor with an I2C digital interface. The following characteristics have been considered for the sensor choice: Wide operating range of 20 kPa to 110 kPa. Temperature compensated utilizing an on-chip temperature sensor. No need for an external ADC or linearization circuits. The pressure and temperature data is fed into an internal high-resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C using the well-known I2C protocol Barometric pressure is also processed by the MCU as height above mean sea level (AMSL) helping to determine the location of the device. Low power consumption. Sensor integration","title":"Barometric Pressure"},{"location":"Components/Urban Sensor Board/#dust-particles-sensor","text":"Warning The following sensor might be replaced in future iterations as it gets replaced by the External PM Sensor connector supporting a Plantowe PMS5003 or PMS7003 The MAXIM MAX30105 6 is an integrated particle-sensing module. Is a high Sensitivity Optical Reflective Solution for detection of wide\u2029a variety of particle sizes. This sensor is aimed at measuring relative air dust levels. However, an algorithm is being developed to support PM 2.5 or PM 10 measurements. At the time the document is being written no data on the sensor lab tests can be provided. The following characteristics have been considered for the sensor choice: No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. Robust Motion Artifact Resilience and -40\u00b0C to +85\u00b0C Operating Temperature Capable of Operating at High Ambient Levels with Excellent Ambient Rejection Capability Includes a temperature sensor for calibrating the temperature dependence of the particle sensing subsystem. Low power consumption Sensor integration","title":"Dust Particles Sensor"},{"location":"Components/Urban Sensor Board/#external-pm-sensor","text":"An external connector on the board supports the connection of a Plantower PMS 5003 or PMS 7003 10 . The device is a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. The sensor can be fully enable or disable in software to save energy when not in use. The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 am No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power The selection is based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017) . Compliance with the NAAQS (US National Ambient Air Quality Standards) is based on 24-h PM mass concentrations [...] Both of the FEM instruments correlate with the 24-h PM2.5 mass measurements with an R2 > 0.99. The PMS PM2.5 concentrations are also well correlated with the 24-h mass average concentration (R2 > 0.88), which is slightly better than the GRIMM research-grade instrument (R2 1\u20444 0.7.). South Coast Air Quality Management District (SCAQMD) recently published preliminary comparisons of the PM2.5 measurements from three PMS 1003s and two FEMs, with high correlations (R2 > 0.9) over a 2-month period. This study demonstrated that the PMS 1003/3003 correlates well with FRMs, FEMs, and research-grade instrumentation under ambient conditions during a series of cold-air pools and in a wind-tunnel environment. Under ambient conditions, this sensor correlates better with an FRM than other low-cost sensors in similar studies. [...] these sensors are a promising tool for identifying relative increases or decreases in PM concentration, complementing sparsely distributed monitoring stations and for assessing and minimizing exposure to PM (Kelly et al. 2017) . Sensor integration","title":"External PM Sensor"},{"location":"Components/Urban Sensor Board/#source-files","text":"Download Check the source code SGX MICS 4514 Technical Datasheet https://sgx.cdistore.com/datasheets/sgx/0278_Datasheet%20MiCS-4514%20rev%2017.pdf INVENSENSE 43432 Technical Datasheet https://www.invensense.com/wp-content/uploads/2015/02/ICS-43432-data-sheet-v1.3.pdf SENSIRION SHT31 Technical Datasheet https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/2_Humidity_Sensors/ ROHM BH1730 Technical Datasheet http://rohmfs.rohm.com/en/products/databook/datasheet/ic/sensor/light/bh1721fvc-e.pdf NXP MPL3115A2 Technical Datasheet http://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf MAXIM 30105 Technical Datasheet https://datasheets.maximintegrated.com/en/ds/MAX30105.pdf ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf","title":"Source files"},{"location":"Components/Urban Sensor Board/MICS Driver Implementation/","text":"MICS heating stage Link The solution present at Urban Sensor Board V2.0 for MICS-4514 sensor's heaters excitation, pretends to make it compatible with a 3.3V global voltage source. The manufacturer reccomend the following circuit topology, with a global supply voltage of 5V. In the datasheet are collected the electrical nominal conditions for that resistors, in order to operate safely with the heater, without damaging it. Besides that, several other possible conditions could also damage early the heater resistors, like the fact of consider a pure PWM signal, with source 5V and subsequent dutty cycle, as excitation. Even if the frequency is relatively high (100kHz), the resistors are forced to operate briefly with 5V, and this accelerates the destruction of this part of the MICS sensor. So its is possible to provide the nominal voltages for heater resistors from a 3.3V source, if we replace the auxiliar resistors (from recomended topology) with corresponding values, to preserve the total power dissipated and current at same normal operating conditions. Even more, we can upgrade the function of the auxiliar resistors adding a capacitor to form a passive RC filter. In the DC or continuous operation, the capacitor is fully charged and the current is limited by the auxiliar resistor. In AC or pulsed operation, the capacitor can be selected to remove this AC component, and feed the heater resistor with a nearly constant voltage or at least with small variations ( 1%). The source for the PWM signal must be buffered, because the resistive load of the system demands currents avobe the SAMD21 can supply. For this purpose, the solution selected is to use a digital hex-inverter buffer, which can drive up to 32mA with each output pin, wich we can paralelize to operate under propper safety factor for the buffer. Simulations Link The first simulations and given values leads to the selection of the RC components values if we set a PWM frequency around 40 kHz. To evaluate the R part of the filter, is needed to take into account the output resistance of the hex-inverter buffer. Prototypes Link We build the circuit into a protoboard, with several IC HEX-INV manufacturers, based on the following schematic: The measures are sumarized in the following table, in which we compare four pre-selected devices, which can fit in our application for size an price considerations. Four cases with paralellized inverters, for each device were performed: pasive load 70R test with DC input, and three tests with 10R+Rheater load at DC input, 60% dutty cycle and 30% dutty cycle. The 74LCX04FT(AE) was selected because it has the lowest LOW output level (0.45V,0.22V), which is considered here as the quality (or close to ideal) of the square wave input source. Final implementation Link The solution implemented in the PCB, has a constant auxilar R (10R+Rout_buff), and constant C (47uF), and also operates at consatant frequency, then, the output power regulation is based on the PWM's dutty cycle. The following circuit represent the implemented schematic. Operation Link First of all, is needed to know the real implemented Rheater of each sensor (which may vary among devices and time), and can be estimated by measuring the V_heater_* at 100% dutty cycle, then: Where Rint_buff can be aproximated with 4 Ohm resistor. The desired_reference_voltage is function of the desired_power_Rheater and dutty cycle. If we set 80mW we can use the value of the Rheater to obtain desired_reference_voltage through tis formula: (Take into account this resistor has a drift over time, therefore is recomended to take periodic measurements of the value of Rheater itself, and check the output power reachability). With selected parameters, after 2ms of PWM operation, the RC reaches the permanent, and then is recomended to take measurements of V_HEATER_ . The loop can be closed to determine the dutty cycle as function of the difference (desired_reference_voltage \u2013 V_HEATER_ (averaged)). Is recomended to average several samples to remove the AC part of the signal. The measured DC signal has a noise of \u00b120mV peak to peak (with triangular distribution). The sign of the PWM signal is inverted due to the action of the inverter, then, a desired x% dutty is obtained as 100%-x%. As initial PWM aproximation to begin to converge close to the regulated dutty cycle can be obtained through this simplification:","title":"MICS Driver Implementation"},{"location":"Components/Urban Sensor Board/MICS Driver Implementation/#mics-heating-stage","text":"The solution present at Urban Sensor Board V2.0 for MICS-4514 sensor's heaters excitation, pretends to make it compatible with a 3.3V global voltage source. The manufacturer reccomend the following circuit topology, with a global supply voltage of 5V. In the datasheet are collected the electrical nominal conditions for that resistors, in order to operate safely with the heater, without damaging it. Besides that, several other possible conditions could also damage early the heater resistors, like the fact of consider a pure PWM signal, with source 5V and subsequent dutty cycle, as excitation. Even if the frequency is relatively high (100kHz), the resistors are forced to operate briefly with 5V, and this accelerates the destruction of this part of the MICS sensor. So its is possible to provide the nominal voltages for heater resistors from a 3.3V source, if we replace the auxiliar resistors (from recomended topology) with corresponding values, to preserve the total power dissipated and current at same normal operating conditions. Even more, we can upgrade the function of the auxiliar resistors adding a capacitor to form a passive RC filter. In the DC or continuous operation, the capacitor is fully charged and the current is limited by the auxiliar resistor. In AC or pulsed operation, the capacitor can be selected to remove this AC component, and feed the heater resistor with a nearly constant voltage or at least with small variations ( 1%). The source for the PWM signal must be buffered, because the resistive load of the system demands currents avobe the SAMD21 can supply. For this purpose, the solution selected is to use a digital hex-inverter buffer, which can drive up to 32mA with each output pin, wich we can paralelize to operate under propper safety factor for the buffer.","title":"MICS heating stage"},{"location":"Components/Urban Sensor Board/MICS Driver Implementation/#simulations","text":"The first simulations and given values leads to the selection of the RC components values if we set a PWM frequency around 40 kHz. To evaluate the R part of the filter, is needed to take into account the output resistance of the hex-inverter buffer.","title":"Simulations"},{"location":"Components/Urban Sensor Board/MICS Driver Implementation/#prototypes","text":"We build the circuit into a protoboard, with several IC HEX-INV manufacturers, based on the following schematic: The measures are sumarized in the following table, in which we compare four pre-selected devices, which can fit in our application for size an price considerations. Four cases with paralellized inverters, for each device were performed: pasive load 70R test with DC input, and three tests with 10R+Rheater load at DC input, 60% dutty cycle and 30% dutty cycle. The 74LCX04FT(AE) was selected because it has the lowest LOW output level (0.45V,0.22V), which is considered here as the quality (or close to ideal) of the square wave input source.","title":"Prototypes"},{"location":"Components/Urban Sensor Board/MICS Driver Implementation/#final-implementation","text":"The solution implemented in the PCB, has a constant auxilar R (10R+Rout_buff), and constant C (47uF), and also operates at consatant frequency, then, the output power regulation is based on the PWM's dutty cycle. The following circuit represent the implemented schematic.","title":"Final implementation"},{"location":"Components/Urban Sensor Board/MICS Driver Implementation/#operation","text":"First of all, is needed to know the real implemented Rheater of each sensor (which may vary among devices and time), and can be estimated by measuring the V_heater_* at 100% dutty cycle, then: Where Rint_buff can be aproximated with 4 Ohm resistor. The desired_reference_voltage is function of the desired_power_Rheater and dutty cycle. If we set 80mW we can use the value of the Rheater to obtain desired_reference_voltage through tis formula: (Take into account this resistor has a drift over time, therefore is recomended to take periodic measurements of the value of Rheater itself, and check the output power reachability). With selected parameters, after 2ms of PWM operation, the RC reaches the permanent, and then is recomended to take measurements of V_HEATER_ . The loop can be closed to determine the dutty cycle as function of the difference (desired_reference_voltage \u2013 V_HEATER_ (averaged)). Is recomended to average several samples to remove the AC part of the signal. The measured DC signal has a noise of \u00b120mV peak to peak (with triangular distribution). The sign of the PWM signal is inverted due to the action of the inverter, then, a desired x% dutty is obtained as 100%-x%. As initial PWM aproximation to begin to converge close to the regulated dutty cycle can be obtained through this simplification:","title":"Operation"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensors/","text":"Inside the MICS Metal Oxide sensors Link The SGX Mics is a Metal Oxyde Resistive sensor capable of reacting to different substances in the atmosphere. In a simplified way, it is comprised of two main elements: A SnO 2 substrate that acts as a sensor element A heater element to keep the substrate in an optimal working area The SnO 2 is a chemically sensitive metal oxide which has interactions with molecules to be detected in the target gas. The reactions that can occur on SnO 2 surface are adsorption and catalytic reactions , which basically mean that the gas molecules can be adsorbed onto the surface or can catalyse reactions (trigger or enhance them). They take place at the so called active sites or grain boundaries, which are areas where the grains that constitute the sensor resistance are in contact with the air (e.g. with metallic contacts). Hence, metal oxide substrate is basically a collection of sites at which different molecules can be absorbed and therefore interact in various manners with the species present in the atmosphere: either through catalytic reaction, surface reaction, grain boundary reaction ( among others ). 2 . The sensor element is typically heated to a few hundred degrees (\u00baC) using a small resistive heater . The regions within the sensor can be described as in Peterson et al. 1 : the surface, which interacts with the gas, the bulk, which is unaffected by it, and the particle boundary, which lies in between these two . The particle boundary is situated at a distance from any material exposed to the atmosphere into the sensor that chemical electrostatic effects can propagate (the so called Debye length), and this is related to the material\u2019s physical properties. At high temperatures, oxygen atoms bond onto the boundary, extracting electrons in the process from the semiconductor\u2019s surface region. The oxygen either then directly reacts with ambient gases, or these gases also bond onto the sensor, which causes more charge carriers to be withdrawn or injected into the surface region. All these effects change the sensor resistance and it is measured accordingly in 1 : In the case of the SGX 4514, the detection of the pollution gases is achieved by measuring the sensing resistance of both sensors. In a generic way, we could characterise the sensor resistance as follows: RED sensor resistance decreases in the presence of CO and hydrocarbons. OX sensor resistance increases in the presence of NO 2 . Finally, the chemical reactions within the resistive element are directly related to temperature and follow an Arrhenius equation type of behaviour. Each sensor's type has a different optimal operation temperature, which is translated into different heating powers for the heater element. Depending on the heating power and transition speeds, different reactions can be facilitated and this can lead to positive effects such as sensor clean up or battery compsuption savings, for example, when heated up in a pulsed profile. On the other hand, it can facilitate sensor poisoning or ageing, which highlights the need of proper sensor characterisation. Sensor Calibration Link The SGX4514 is a low cost sensor originally ment to detect instances or trends of target gas in the atmosphere 4 5 . The applications intended for these sensors are \u2018event sensing\u2018 applications and the level of accuracy required is not necessarily within regulatory standards. Furthermore, these sensors should not be used with safety related issues. However, despite the low cost nature of these sensors, they have been subject of a great deal of research 1 2 3 and have been reported to give considerably good results in field applications. Before delving into the details of sensor calibration, we will try to understand what these sensors are and how they should be handled. Some important definitions are: Sensor baseline resistance : is the resistance that the sensor exhibits when it's not powered Sensor sensitivity : is the resistance variation with variations in the target gas Sensor cross-sensitivity : is the resistance variation with variations of gases other than the target gas Sensor poisoning : an irreversible resistance variation provoked by the reaction of gases other than the target gas Source: Peterson et al. 1 Peterson et al. 1 describes the various types of interactions between atmospheric gases and a MOS sensor surface. In the image above, the leftmost region describes the unpowered behaviour, or base resistance . The three other regions of the diagram describe different processes that actually occur simultaneously to varying degrees. The sensor\u2019s output is the resistance across the whole of the sensor material, which forms a resistor network with contributions from both the bulk and surface regions. The model described in 1 also explains the wide variation in base resistance between individual sensors of the same type, as the random nature of the surface geometry means an equally random network of resistances. This diagram is a two-dimensional representation of a three-dimensional material; in an actual sensor, the sensitive region is spread into the surface with a distance dependent on the grain size and arrangement resulting from the sintering. Each sensor will then have a different resistance in air and how much this baseline resistance changes with the concentration of the target gas will also differ (what we defined above as sensitivity). Therefore to convert from resistance readings to concentration it is necessary to derive a calibration curve for each sensor . This will require measuring the resistances in air and at a number of gas concentrations over the desired range. It is important that the concentrations are in a background of air as Oxygen is needed for the sensor to work correctly. As stated in 2 , the sensor\u2019s response is only partially a function of the amount of gas to which the surface is exposed. Instead, the sensor will have a baseline resistance that is related to the bulk and particle boundary resistance. Because of the random geometry of the granular sensor surface, the baseline resistance will vary between individual sensors. The change in resistance with the change in gas concentration is generally not a linear response. The response can be measured and fitted to a polynomial relationship , with interactions from other metrics such as temperature, humidity and other gases. It has been proved that air flow around the sensor yields better sensor reactivity, and that the usage of PTFE filters also helps reducing cross-sensitivity and sensor poisoning. An important practical consideration with any in situ air quality sensor design is ensuring adequate flow of sampling air through the device. Stale air inside a casing will produce unrepresentative results , and even sensors mounted outside a casing might not get a properly-mixed sample. Source: Peterson et al. 1 Although the deployment of multiple different sensors can compensate for the cross-sensitivity issues in calibration, it cannot eliminate it. MOS sensors can thus be used only in situations where any interfering species can either be measured by other means, or they must be calibrated regularly and used in locations where the background varies in concentration slowly compared with the target gases. As well, the sensor drift over time is an important issue that requires sensor recalibration over time. There are two major factors in the longevity of a sensor\u2019s calibration. The first is the natural degradation of the heater element, which becomes hotter over prolonged use and causes the sensor\u2019s response profile to vary. The second is the effect of slowly-varying interfering gases, which over the course of months shifts the sensor\u2019s baseline. The first problem may have an engineering solution, but the second will involve taking the results of the tests in an artificial atmosphere, identifying the most critical species and either measuring or possibly modelling their likely concentrations during deployments. An analytical approach to counteracting this drift might be \"merging calibrations\", where a sensor is calibrated at the start and end of a four-month campaign, and the coefficients gradually change from one end of the experiment run to the other. Having all this in mind, the sensor calibration we follow is comprised of the following steps: Sensor behaviour characterisation under different temperature profiles Sensor baseline and sensitivity characterisation in controlled conditions Sensor deployment with reference measurements collocation and model calibration The use of deployment campaigns is of utmost importance in order to develop sensor models that are reality proof . With the possibility of collecting the data with the SmartCitizen Platform and the data treatment provided by the Sensor Calibration Framework , we are able to iterate over the different sensor calibration possibilities, ranging from Ordinary Linear Regression or more advanced techniques such as ML models such as LSTMs networks. Field results Link In this section, we will detail some of the MOS related results obtained during the sensor validation campaigns detailed below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Living Lab Stations were deployed in two different sites, with two Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Living Lab Station was deployed with two Citizen kits For both results shown below, we used an LSTM with 200 epochs training and the following structure: from keras.models import Sequential from keras.layers import Dense , Activation , LSTM , Dropout model = Sequential () layers = [ 50 , 100 , 1 ] model . add ( LSTM ( layers [ 0 ], return_sequences = True , input_shape = ( train_X . shape [ 1 ], train_X . shape [ 2 ]))) model . add ( Dropout ( 0.2 )) model . add ( LSTM ( layers [ 1 ], return_sequences = False )) model . add ( Dropout ( 0.2 )) model . add ( Dense ( output_dim = layers [ 2 ])) model . add ( Activation ( linear )) model . compile ( loss = mse , optimizer = rmsprop ) Carbon Monoxide Link The CO model included the following features: CO_{R}^{-1} CO_{R}^{-1} , CO_R^{-2} CO_R^{-2} , Temp Temp and Temperature^2 Temperature^2 . The results can be seen below: Nitrogen Dioxide Link The NO 2 model included the following features: NO~2~_{R} NO~2~_{R} , NO~2~_R^{-2} NO~2~_R^{-2} , Light, Temp Temp and Temperature^2 Temperature^2 . The results can be seen below: Warning This test campaign contains a short amount of data to be used as a training dataset for a LSTM algorithm. Therefore, this is just to considered as an use case example and further tests and data should be carried out to train broader models. References Link Practical Use of Metal Oxide Semiconductor Gas Sensors for Measuring Nitrogen Dioxide and Ozone in Urban Environments Modelling Of Water Adsorption On SnO 2 Surface MICS-4514 Datasheet Frequently-Asked-Questions-for-MiCS-Gas-Sensors SGX Metal Oxide Gas Sensors - How to use and how they perform Sensors 2017, 17, 1653","title":"Metal Oxide Sensors"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensors/#inside-the-mics-metal-oxide-sensors","text":"The SGX Mics is a Metal Oxyde Resistive sensor capable of reacting to different substances in the atmosphere. In a simplified way, it is comprised of two main elements: A SnO 2 substrate that acts as a sensor element A heater element to keep the substrate in an optimal working area The SnO 2 is a chemically sensitive metal oxide which has interactions with molecules to be detected in the target gas. The reactions that can occur on SnO 2 surface are adsorption and catalytic reactions , which basically mean that the gas molecules can be adsorbed onto the surface or can catalyse reactions (trigger or enhance them). They take place at the so called active sites or grain boundaries, which are areas where the grains that constitute the sensor resistance are in contact with the air (e.g. with metallic contacts). Hence, metal oxide substrate is basically a collection of sites at which different molecules can be absorbed and therefore interact in various manners with the species present in the atmosphere: either through catalytic reaction, surface reaction, grain boundary reaction ( among others ). 2 . The sensor element is typically heated to a few hundred degrees (\u00baC) using a small resistive heater . The regions within the sensor can be described as in Peterson et al. 1 : the surface, which interacts with the gas, the bulk, which is unaffected by it, and the particle boundary, which lies in between these two . The particle boundary is situated at a distance from any material exposed to the atmosphere into the sensor that chemical electrostatic effects can propagate (the so called Debye length), and this is related to the material\u2019s physical properties. At high temperatures, oxygen atoms bond onto the boundary, extracting electrons in the process from the semiconductor\u2019s surface region. The oxygen either then directly reacts with ambient gases, or these gases also bond onto the sensor, which causes more charge carriers to be withdrawn or injected into the surface region. All these effects change the sensor resistance and it is measured accordingly in 1 : In the case of the SGX 4514, the detection of the pollution gases is achieved by measuring the sensing resistance of both sensors. In a generic way, we could characterise the sensor resistance as follows: RED sensor resistance decreases in the presence of CO and hydrocarbons. OX sensor resistance increases in the presence of NO 2 . Finally, the chemical reactions within the resistive element are directly related to temperature and follow an Arrhenius equation type of behaviour. Each sensor's type has a different optimal operation temperature, which is translated into different heating powers for the heater element. Depending on the heating power and transition speeds, different reactions can be facilitated and this can lead to positive effects such as sensor clean up or battery compsuption savings, for example, when heated up in a pulsed profile. On the other hand, it can facilitate sensor poisoning or ageing, which highlights the need of proper sensor characterisation.","title":"Inside the MICS Metal Oxide sensors"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensors/#sensor-calibration","text":"The SGX4514 is a low cost sensor originally ment to detect instances or trends of target gas in the atmosphere 4 5 . The applications intended for these sensors are \u2018event sensing\u2018 applications and the level of accuracy required is not necessarily within regulatory standards. Furthermore, these sensors should not be used with safety related issues. However, despite the low cost nature of these sensors, they have been subject of a great deal of research 1 2 3 and have been reported to give considerably good results in field applications. Before delving into the details of sensor calibration, we will try to understand what these sensors are and how they should be handled. Some important definitions are: Sensor baseline resistance : is the resistance that the sensor exhibits when it's not powered Sensor sensitivity : is the resistance variation with variations in the target gas Sensor cross-sensitivity : is the resistance variation with variations of gases other than the target gas Sensor poisoning : an irreversible resistance variation provoked by the reaction of gases other than the target gas Source: Peterson et al. 1 Peterson et al. 1 describes the various types of interactions between atmospheric gases and a MOS sensor surface. In the image above, the leftmost region describes the unpowered behaviour, or base resistance . The three other regions of the diagram describe different processes that actually occur simultaneously to varying degrees. The sensor\u2019s output is the resistance across the whole of the sensor material, which forms a resistor network with contributions from both the bulk and surface regions. The model described in 1 also explains the wide variation in base resistance between individual sensors of the same type, as the random nature of the surface geometry means an equally random network of resistances. This diagram is a two-dimensional representation of a three-dimensional material; in an actual sensor, the sensitive region is spread into the surface with a distance dependent on the grain size and arrangement resulting from the sintering. Each sensor will then have a different resistance in air and how much this baseline resistance changes with the concentration of the target gas will also differ (what we defined above as sensitivity). Therefore to convert from resistance readings to concentration it is necessary to derive a calibration curve for each sensor . This will require measuring the resistances in air and at a number of gas concentrations over the desired range. It is important that the concentrations are in a background of air as Oxygen is needed for the sensor to work correctly. As stated in 2 , the sensor\u2019s response is only partially a function of the amount of gas to which the surface is exposed. Instead, the sensor will have a baseline resistance that is related to the bulk and particle boundary resistance. Because of the random geometry of the granular sensor surface, the baseline resistance will vary between individual sensors. The change in resistance with the change in gas concentration is generally not a linear response. The response can be measured and fitted to a polynomial relationship , with interactions from other metrics such as temperature, humidity and other gases. It has been proved that air flow around the sensor yields better sensor reactivity, and that the usage of PTFE filters also helps reducing cross-sensitivity and sensor poisoning. An important practical consideration with any in situ air quality sensor design is ensuring adequate flow of sampling air through the device. Stale air inside a casing will produce unrepresentative results , and even sensors mounted outside a casing might not get a properly-mixed sample. Source: Peterson et al. 1 Although the deployment of multiple different sensors can compensate for the cross-sensitivity issues in calibration, it cannot eliminate it. MOS sensors can thus be used only in situations where any interfering species can either be measured by other means, or they must be calibrated regularly and used in locations where the background varies in concentration slowly compared with the target gases. As well, the sensor drift over time is an important issue that requires sensor recalibration over time. There are two major factors in the longevity of a sensor\u2019s calibration. The first is the natural degradation of the heater element, which becomes hotter over prolonged use and causes the sensor\u2019s response profile to vary. The second is the effect of slowly-varying interfering gases, which over the course of months shifts the sensor\u2019s baseline. The first problem may have an engineering solution, but the second will involve taking the results of the tests in an artificial atmosphere, identifying the most critical species and either measuring or possibly modelling their likely concentrations during deployments. An analytical approach to counteracting this drift might be \"merging calibrations\", where a sensor is calibrated at the start and end of a four-month campaign, and the coefficients gradually change from one end of the experiment run to the other. Having all this in mind, the sensor calibration we follow is comprised of the following steps: Sensor behaviour characterisation under different temperature profiles Sensor baseline and sensitivity characterisation in controlled conditions Sensor deployment with reference measurements collocation and model calibration The use of deployment campaigns is of utmost importance in order to develop sensor models that are reality proof . With the possibility of collecting the data with the SmartCitizen Platform and the data treatment provided by the Sensor Calibration Framework , we are able to iterate over the different sensor calibration possibilities, ranging from Ordinary Linear Regression or more advanced techniques such as ML models such as LSTMs networks.","title":"Sensor Calibration"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensors/#field-results","text":"In this section, we will detail some of the MOS related results obtained during the sensor validation campaigns detailed below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Living Lab Stations were deployed in two different sites, with two Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Living Lab Station was deployed with two Citizen kits For both results shown below, we used an LSTM with 200 epochs training and the following structure: from keras.models import Sequential from keras.layers import Dense , Activation , LSTM , Dropout model = Sequential () layers = [ 50 , 100 , 1 ] model . add ( LSTM ( layers [ 0 ], return_sequences = True , input_shape = ( train_X . shape [ 1 ], train_X . shape [ 2 ]))) model . add ( Dropout ( 0.2 )) model . add ( LSTM ( layers [ 1 ], return_sequences = False )) model . add ( Dropout ( 0.2 )) model . add ( Dense ( output_dim = layers [ 2 ])) model . add ( Activation ( linear )) model . compile ( loss = mse , optimizer = rmsprop )","title":"Field results"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensors/#carbon-monoxide","text":"The CO model included the following features: CO_{R}^{-1} CO_{R}^{-1} , CO_R^{-2} CO_R^{-2} , Temp Temp and Temperature^2 Temperature^2 . The results can be seen below:","title":"Carbon Monoxide"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensors/#nitrogen-dioxide","text":"The NO 2 model included the following features: NO~2~_{R} NO~2~_{R} , NO~2~_R^{-2} NO~2~_R^{-2} , Light, Temp Temp and Temperature^2 Temperature^2 . The results can be seen below: Warning This test campaign contains a short amount of data to be used as a training dataset for a LSTM algorithm. Therefore, this is just to considered as an use case example and further tests and data should be carried out to train broader models.","title":"Nitrogen Dioxide"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensors/#references","text":"Practical Use of Metal Oxide Semiconductor Gas Sensors for Measuring Nitrogen Dioxide and Ozone in Urban Environments Modelling Of Water Adsorption On SnO 2 Surface MICS-4514 Datasheet Frequently-Asked-Questions-for-MiCS-Gas-Sensors SGX Metal Oxide Gas Sensors - How to use and how they perform Sensors 2017, 17, 1653","title":"References"},{"location":"Components/Urban Sensor Board/Noise Sensor/","text":"Inside the Noise Sensor Link Source files Link Download Check the source code Basic Concepts and theory Link Basics of MEMs I2S Microphone Link The new Urban Sensor Board SCK 2.0 comes with a digital MEMs I2S microphone . There is a wide range of possibilities in the market, and our pick was the INVENSENSE (now TDK) ICS43432 : a tiny digital MEMs microphone with I2S output. There is an extensive documentation at TDK's website coming from the former and we would recommend to review the nicely put documents for those interested in the topic. Image credit: Invensense ICS43432 To begin with, we'll talk about the microphone itself. The MEMs microphone comes with a transducer element which converts the sound pressure into electric signals. The sound pressure reaches the transducer through a hole drilled in the package and the transducer's signal is sent to an ADC which provides with a signal which can be pulse density modulated (PDM) or in I2S format. Since the ADC is already in the microphone, we have an all-digital audio capture path to the processor and it\u2019s less likely to pick up interferences from other RF, such as the WiFi, for example. The I2S has the advantage of a decimated output, and since the SAMD21 has an I2S port, this allows us to connect it directly to the microcontroller with no CODEC needed to decode the audio data. Additionally, there is a bandpass filter, which eliminates DC and low frequency components (i.e. at fs = 48kHz, the filter has -3dB corner at 3,7Hz) and high frequencies at 0,5\u00b7fs (-3dB cutoff). Both specifications are important to consider when analysing the data and discarding unusable frequencies. The microphone acoustic response has to be considered as well, with subsequent equalisation in the data treatment in order. We will review these points on dedicated sections. Image credit: ICS43432 Datasheet - TDK Invensense I2S Protocol Link The I2S protocol ( Inter-IC-Sound ) is a serial bus interface which consists of: a bit clock line or Serial Clock ( SCK ), a word clock line or Word Select ( WS ) and a multiplexed Serial Data line ( SD ). The SD is transmitted in two\u2019s complement with MSB first, with a 24-bit word length in the microphone we picked. The WS is used to indicate which channel is being transmitted (left or right). In the case of the ICS43432, there is an additional pin which corresponds with the L/R, allowing to use the left or right channel to output the signal and the use of stereo configurations. When set to left, the data follows WS\u2019s falling edge and when set to right, the WS\u2019s rising edge. For the SAMD21 processor, there is a well developed I2S library that will take control of this configuration. Image credit: I2S bus specification - Philips Semiconductors To finalise, we would like to highlight that the SD line of the I2S protocol is quite delicate at high frequencies and it is largely affected by noise in the path the line follows. If you want to try this at home (for example with an Arduino Zero and an I2S microphone like this one , it is important not to use cables in this line and to connect the output pin directly to the board, to avoid having interfaces throughout the SD line. One interesting way to see this is that every time the line sees a medium change, part of it will be reflected and part will be transmitted, just like any other wave. This means that introducing a cable for the line will provoke at least three medium changes and a potential signal quality loss much higher than a direct connection. Apart from this point, the I2S connection is pretty straight forward and it is reasonably easy to retrieve data from the line and start playing around with some FFT analysis. Basics of weighting and human hearing Link The world of acoustics and signal processing for audio analysis is worth several book-length discussions. We might as well try to give an insight of our intentions within this world since we introduced ourselves in it by picking a digital microphone with a quite nice range of capabilities. The very first thing we would like to do is to be able to perform weighting on the buffer we receive from the microphone through the I2S. To explain a bit further on what weighting is, it is no more than a transformation from the real-world sound pressure levels (SPL) travelling around in the air to what our ears can perceive. Just that. Image credit: Human hearing - DSP Guide There are several studies and models of what we actually perceive and depending on them, we have several types of the so called weighting functions . Some of them have been standarised for the purpose of SPL measurement, finding different types like A-weighting (the most common one), B-weighting, D (both in disuse) and others. In the frequency domain, they look like this: Image credit: A-weighting - Wikipedia This means that, even if the are high sound pressure levels floating around in the air, we might not hear them just because of the frequency they are at. Normally humans can hear from something around 20Hz to 20kHz, although most adults might not hear anything in out-of-laboratory conditions above 15kHz. Some animals though, can perceive a great range of frequencies , and for example mouses can hear up to 80kHz! So, now we know what this all is about, the I2S microphone is going to help us understand better how beluga whales communicate among themselves ... But also! The I2S microphone is interesting in order to understand sources of urban noise pollution since it provides us with a raw SPL buffer we can play with. As well, we can obtain dBA levels (SPL with a-weighting correction) by processing this buffer in several ways and calculate the RMS level of the resulting signal. In the Part II we will go through the mathematics of the signal processing itself and talk a bit about FFT, signal filtering and some other geeky stuff! RMS and FFT algorithm simplified Link In this paragraph we'll continue with some bits and pieces about acoustics and signal processing we started talking about in section 1.2. We are going to talk about the mathematics behind these applications and how we'll use them in the signal processing for obtaining our weighting for the SCK. In the previous section we introduced the concept of weighting and our interest on calculating the sound pressure level in different scales. Normally, SPL is expressed in RMS levels, or root mean square . This is nothing more than a modified arithmetic average, where each term of the expression is added in its square form. Therefore, to keep the same units, we then take the square root of all the average and we have: x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} The interesting thing about the RMS level, is that it expresses an average signal level throughout the signal, and it actually relates to the peak level of sinusoid wave by \u221a2. Therefore, it is a very interesting way to express average levels for signals and for that reason, it's the common standard used. Image credit: Sine wave parameters- Wikipedia Now that we know how to calculate the RMS level of our signal, let's go into something more interesting: how do we actually perform the weighting? Well, if you recall the previous section, when we talked about hearing, we were talking about the different hearing capabilities in terms of frequencies (in humans, mouses, beluga whales... ). Therefore, something interesting to know about our signal is its frequency content , so that we are able to perform the weighting. For this purpose, we have the FFT algorithm , which we won't tell you is easy, but we'll try to put it simply here. So FFT stands for Fast Fourier Transform , and it's an algorithm capable of performing a Fourier Transform in a simplified and efficient way (that's where the fast comes in). What it does in a detailed mathematical way is something quite complicated and we don't want to bore you and ourselves with the details; but being practical, it is basically a convertion between the signal in time domain and its frequency domain components. Interestingly, this process is reversible and the other way around it is called IFFT ( I for Inverse , obviously...). Image credit: Smart Citizen In the example above, things in the time domain get a bit messy, but in the frequency domain we can clearly see the composition of two sine waves of the same amplitude of roughly 40Hz and 120Hz. The FFT algorithm hence helps us digest the information contained in a signal in a more visually understandable way. We will cover more details about the process and it's implementation in future sections. For this introduction, let's move on to what we actually want to do: the much anticipated weighting . At this point, our task is fairly easy: we just have to multiply both: our signal in the frequency domain with the weighting function and that's it! If we have a look at the figure below, in the time and frequency domain, the signals look like this: Image credit: Smart Citizen This example shows how our ears are only capable of perceiving the signal in red, but the actual sound components are in blue -- being much higher in the amplitude spectrum. If you want to get into the thick of it, here you have the actual implementation in Matlab of the A-weighting function that we'll use in the SCK V2.0. And finally, to close, let's take a look at the whole chain of processing, where we will continue in future sections: st= start: Signal acquisition e= end: RMS calculation op= operation: Windowing op2= operation: FFT op3= operation: Spectrum Normalisation op4= operation: Equalisation op5= operation: A-weighting st- op- op2- op3- op4- op5- e Image credit: Smart Citizen This is the whole signal treatment process we use for the I2S microphone ICS43432. We will have a look at windowing and its use in future sections, as well as its implementation in the SAMD21 Cortex M0+ for our firmware. NB NB : Being mathematical purist, there is yet another possibility for this procedure using convolution in time domain, which we will cover in future sections. Pre/post processing: signal windowing and equalisation Link Signal windowing Link In this section we are going to describe how we have to pre-post process our signals in order to obtain the results in the manner we are expecting. These are very important steps in our processing chain, since the FFT algorithms -or convolution FIR Filters- won't be able to cope with our system's limitations. These limitations might not be obvious at the beginning, but you really don't want to ignore them while designing your system, since they'll invalidate many of your measurements. If this sounds greek to you, consider reading Part I and Part II in this forum before continuing with this post. The very first of these limitations, is the fact that our microphone is, in fact, taking discrete samples of the ambient noise surrounding it. This means that, from the very beginning, we are missing some pieces of information and we will never be able to process them. But it's OK! For the purpose of our analysis, we don't need to sample continuosly and this situation is easily bypassed. Image credit: NUTAQ - Signal processing Discrete sampling has two main consequences for us: the first one is that we are taking samples once every 1/f_s 1/f_s , where f_s f_s is the sampling frequency. Normal audio systems sample at 44,1kHz, but this number might vary depending on the application. If you remember this chart , you might be wondering why we have to sample at such a high frequency. Image credit: Signal acquisition - Adinstruments This is due to the Nyquist sampling criterion , which states that at a minimum, we have to sample at double the maximum frequency we want to analyse . Since humans hearing has a limited frequency range that goes up to 20kHz in some cases, it is reasonable to use something around 40kHz. With this, the Nyquist criterion solves the so called aliasing problem , in which several sinusoid signals could fit the same sampling pattern if the number of samples is too low: Image credit: Wikipedia - Aliasing The second of the discrete sampling limitation comes from the amount of samples we are able to handle at a time . Normally, this is due to memory limitations in the RAM, although we'll see in the future where to allocate them. Nevertheless, it is not useful to handle buffers that are too long , since at some point, the increase of buffer length does not provide any additional information. Buffer length requirements in our case come from the minimum frequency we want to sample, which is around 20Hz . Doing some quick math, we need 0,05s worth of sample buffer, which at 44,1kHz is roughly 2200 samples . This is equally too many samples, considering that each could be allocated as a uint8_t , taking up to 16kB just for the raw buffer! This is where signal windowing kicks in. Imagine that we have a very-low-frequency sinusoid and that we are not able to sample completely the whole sine wave, due to buffer limitations. By definition, our system is assuming that the discrete samples we measure are constantly being repeated in the environment, one after the other: Image credit: Smart Citizen When we take the FFT of this signal, we see undesired frequencies that make our frequency spectrum invalid. This is called spectral leakage and it's mitigated by the use of windows (math funcions, not the OS). These windows operate by smoothing the edges of our measurement and preventing the jumps in the signal helping the FFT algorithm to properly analyse the signals. Image credit: Smart Citizen With the use of signal windowing , more specifically with the use of the hamming window , we are then able to reduce the amount of samples needed to roughly 1000 samples. Now we are down to 50% of the memory allocation needed without windowing . You can see the effect on the RMS relative errors in the image below, where the trend of the Hann (another common window) and the Hamming treated buffers, with respect to the frequency tends to stabilise much more quickly than the raw buffers. Image credit: Smart Citizen There is a wide range of functions to use and the decision depends on your application. For audio applications, the most common ones are the Hann, Hamming, and Blackmann. We chose the Hamming because it's trend is to stabilise a bit more quickly than the rest, although the differencies are minimal. For your reference, there is a very interesting description of all these phenomena in this article , where you'll find a more mathematical approach. Info Talk about the microphone response and how to correct it. Filtering and convolution Link In this section we are going to talk about a different approach to the FFT Analysis we have seen in previous sections. What if we don't like the FFT algorithm and we only want to obtain a dBA or dBC results? There is a fairly simple solution to this problem, and it's called filtering . Filtering is a very common technique in signal acquisition that eliminates some frequency components of the raw signal. Examples of filters you very likely have heard of are low-pass, high-pass and band-pass filters . These only let pass the low, high or a defined interval range of frequencies, mostly cancelling out the rest. In the frequency domain, they basicly multiply the spectrum of our signal with its filter spectrum. Exactly what we have done with the weighting. Image credit: Norwegian Creations First, it is important to get a glimpse of the math behind the filters and why they do their magic. And for this, the most important thing we need to know is called convolution . Image credit: River Trail For the purpose of audio analysis , let's consider we have an input vector, a filter kernel and an output vector. Our input vector can be the raw audio signal we have captured, being the output signal the result of the convolution operation. The filter kernel is the characteristic of the filter and will be, for this example, a one dimension array. What the convolution operation is going to do, in a very very very simplified way , is to sweep through the input sample and multiply each component with it's corresponding filter kernel component, then sum the results and put them in the corresponding output sample. If we put some math notation and call x[n] to the input vector, h[n] to the filter kernel and y[n] to the output vector, it all ends up looking like this: Image credit: DSP Guide Now, the most interesting thing of all this theory is that convolution and multiplication are equivalent operations when we jump from the time to the frequency domain . This means that multiplication in time domain equals to convolution in frequency domain, and more importantly for us, convolution in the time domain, equals to multiplication in the frequency domain . To sum up, the relationship between both domains would look like: Image credit: SmartCitizen Therefore, what we could do is to define a custom filter function and apply it via convolution to our input buffer. This is basically a FIR filter , where FIR stands for Finite Impulse Response . There is another type of filters called IIR , where IIR stands for Infinite impulse response . The difference between them is that FIR uses convolution and IIR uses recursion . The concept of recursion is very simple and it's nothing else than a simplification of the convolution, given that in the convolution algorithm, there are many recursive operations that we repeat over an over and we can implement into a smarter algorithm. Normally, IIR filters are more efficient in terms of speed and memory , but we need to specify a series of coefficients, and it's tricky, if not impossible, to create a custom filter response. Image credit: DSP Guide So finally! How can we avoid using the FFT algorithm to extract the desired frequency content of a signal and recreate the signal without it? Sounds complex, but now we know that we can use a FIR filter , with a custom frequency response and apply it via convolution to our input buffer. As simple as that. The custom frequency response, with the proper math, can be optained by applying the IFFT algorithm to the desired frequency response (for example, the A-weighting function). You can have a look to this example if you want to create a custom filter function in octave , with A or C weighting and implement it to a FIR filter in C++. Image credit: SmartCitizen Also, if you are really into it, you can read more about convolution and other DSP topics, we would recommended to go through this fantastic guide . AFSK Analyser Link In this section we are going to talk about a new feature we are planning to introduce in the upcoming version of the SCK: a FSK communication protocol via Audio (A-FSK). You might have read about this technique and it\u2019s usage in the Amazon Dash configuration process, and on the post today we are going to describe very briefly the work in progress for this feature. So! FSK stands for Frequency Shift Keying, which is a form of transmission through frequency variations on the carrying waveforms. It\u2019s major counterpart is the so called ASK, or Amplitude Shift Keying, in which the transmission is carried out via amplitude variations. A very simple form of ASK is OOK, which stands for On-Off-Keying, in which the amplitude of the carrier wave oscillates between a value and nothingness: Image credit: Electric Stack Exchange As in many other situations, there is a trade off between the options on the table: ASK or FSK? Maybe another one? The main disadvantage of ASK it is said to have a higher probability of error with respect to FSK, since noise interference affects amplitude of the transmitted wave. FSK, on the other hand, it is said to have a lower bandwidth efficiency. However, since we have talked about FFT quite a lot now, we thought FSK would be our best bet and also, because maybe bandwidth is not such a big deal after all as we can see below. Then, the idea is to implement an algorithm that is able to identify if the sound transmitted from an emitter (i.e. a smartphone) contains a series of reference frequencies in certain known spots. Following this principle, our aim is to transmit a byte per sound wave, hence, in a sound wave containing up to 8 possible carrier frequencies that might or not be activated. The activation (or not) of these frequencies in the analysed spectrum will yield a 1 or a 0, that we can use on a bit mask and extract 8-bit ASCII characters codes : Image credit: Martin Melhus The emitter could be based on the Web Audio API, as the example from Martin Melhus above from his project on a Web Audio Modem. Finally, the receiver would be our beloved I2S Mems microphone that we have been talking about for so long now, doing a FFT algorithm and detecting the peaks in it, identifying the carrier frequencies activation. Source files Link Download Check the source code","title":"Noise Sensor"},{"location":"Components/Urban Sensor Board/Noise Sensor/#inside-the-noise-sensor","text":"","title":"Inside the Noise Sensor"},{"location":"Components/Urban Sensor Board/Noise Sensor/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Components/Urban Sensor Board/Noise Sensor/#basic-concepts-and-theory","text":"","title":"Basic Concepts and theory"},{"location":"Components/Urban Sensor Board/Noise Sensor/#basics-of-mems-i2s-microphone","text":"The new Urban Sensor Board SCK 2.0 comes with a digital MEMs I2S microphone . There is a wide range of possibilities in the market, and our pick was the INVENSENSE (now TDK) ICS43432 : a tiny digital MEMs microphone with I2S output. There is an extensive documentation at TDK's website coming from the former and we would recommend to review the nicely put documents for those interested in the topic. Image credit: Invensense ICS43432 To begin with, we'll talk about the microphone itself. The MEMs microphone comes with a transducer element which converts the sound pressure into electric signals. The sound pressure reaches the transducer through a hole drilled in the package and the transducer's signal is sent to an ADC which provides with a signal which can be pulse density modulated (PDM) or in I2S format. Since the ADC is already in the microphone, we have an all-digital audio capture path to the processor and it\u2019s less likely to pick up interferences from other RF, such as the WiFi, for example. The I2S has the advantage of a decimated output, and since the SAMD21 has an I2S port, this allows us to connect it directly to the microcontroller with no CODEC needed to decode the audio data. Additionally, there is a bandpass filter, which eliminates DC and low frequency components (i.e. at fs = 48kHz, the filter has -3dB corner at 3,7Hz) and high frequencies at 0,5\u00b7fs (-3dB cutoff). Both specifications are important to consider when analysing the data and discarding unusable frequencies. The microphone acoustic response has to be considered as well, with subsequent equalisation in the data treatment in order. We will review these points on dedicated sections. Image credit: ICS43432 Datasheet - TDK Invensense","title":"Basics of MEMs I2S Microphone"},{"location":"Components/Urban Sensor Board/Noise Sensor/#i2s-protocol","text":"The I2S protocol ( Inter-IC-Sound ) is a serial bus interface which consists of: a bit clock line or Serial Clock ( SCK ), a word clock line or Word Select ( WS ) and a multiplexed Serial Data line ( SD ). The SD is transmitted in two\u2019s complement with MSB first, with a 24-bit word length in the microphone we picked. The WS is used to indicate which channel is being transmitted (left or right). In the case of the ICS43432, there is an additional pin which corresponds with the L/R, allowing to use the left or right channel to output the signal and the use of stereo configurations. When set to left, the data follows WS\u2019s falling edge and when set to right, the WS\u2019s rising edge. For the SAMD21 processor, there is a well developed I2S library that will take control of this configuration. Image credit: I2S bus specification - Philips Semiconductors To finalise, we would like to highlight that the SD line of the I2S protocol is quite delicate at high frequencies and it is largely affected by noise in the path the line follows. If you want to try this at home (for example with an Arduino Zero and an I2S microphone like this one , it is important not to use cables in this line and to connect the output pin directly to the board, to avoid having interfaces throughout the SD line. One interesting way to see this is that every time the line sees a medium change, part of it will be reflected and part will be transmitted, just like any other wave. This means that introducing a cable for the line will provoke at least three medium changes and a potential signal quality loss much higher than a direct connection. Apart from this point, the I2S connection is pretty straight forward and it is reasonably easy to retrieve data from the line and start playing around with some FFT analysis.","title":"I2S Protocol"},{"location":"Components/Urban Sensor Board/Noise Sensor/#basics-of-weighting-and-human-hearing","text":"The world of acoustics and signal processing for audio analysis is worth several book-length discussions. We might as well try to give an insight of our intentions within this world since we introduced ourselves in it by picking a digital microphone with a quite nice range of capabilities. The very first thing we would like to do is to be able to perform weighting on the buffer we receive from the microphone through the I2S. To explain a bit further on what weighting is, it is no more than a transformation from the real-world sound pressure levels (SPL) travelling around in the air to what our ears can perceive. Just that. Image credit: Human hearing - DSP Guide There are several studies and models of what we actually perceive and depending on them, we have several types of the so called weighting functions . Some of them have been standarised for the purpose of SPL measurement, finding different types like A-weighting (the most common one), B-weighting, D (both in disuse) and others. In the frequency domain, they look like this: Image credit: A-weighting - Wikipedia This means that, even if the are high sound pressure levels floating around in the air, we might not hear them just because of the frequency they are at. Normally humans can hear from something around 20Hz to 20kHz, although most adults might not hear anything in out-of-laboratory conditions above 15kHz. Some animals though, can perceive a great range of frequencies , and for example mouses can hear up to 80kHz! So, now we know what this all is about, the I2S microphone is going to help us understand better how beluga whales communicate among themselves ... But also! The I2S microphone is interesting in order to understand sources of urban noise pollution since it provides us with a raw SPL buffer we can play with. As well, we can obtain dBA levels (SPL with a-weighting correction) by processing this buffer in several ways and calculate the RMS level of the resulting signal. In the Part II we will go through the mathematics of the signal processing itself and talk a bit about FFT, signal filtering and some other geeky stuff!","title":"Basics of weighting and human hearing"},{"location":"Components/Urban Sensor Board/Noise Sensor/#rms-and-fft-algorithm-simplified","text":"In this paragraph we'll continue with some bits and pieces about acoustics and signal processing we started talking about in section 1.2. We are going to talk about the mathematics behind these applications and how we'll use them in the signal processing for obtaining our weighting for the SCK. In the previous section we introduced the concept of weighting and our interest on calculating the sound pressure level in different scales. Normally, SPL is expressed in RMS levels, or root mean square . This is nothing more than a modified arithmetic average, where each term of the expression is added in its square form. Therefore, to keep the same units, we then take the square root of all the average and we have: x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} The interesting thing about the RMS level, is that it expresses an average signal level throughout the signal, and it actually relates to the peak level of sinusoid wave by \u221a2. Therefore, it is a very interesting way to express average levels for signals and for that reason, it's the common standard used. Image credit: Sine wave parameters- Wikipedia Now that we know how to calculate the RMS level of our signal, let's go into something more interesting: how do we actually perform the weighting? Well, if you recall the previous section, when we talked about hearing, we were talking about the different hearing capabilities in terms of frequencies (in humans, mouses, beluga whales... ). Therefore, something interesting to know about our signal is its frequency content , so that we are able to perform the weighting. For this purpose, we have the FFT algorithm , which we won't tell you is easy, but we'll try to put it simply here. So FFT stands for Fast Fourier Transform , and it's an algorithm capable of performing a Fourier Transform in a simplified and efficient way (that's where the fast comes in). What it does in a detailed mathematical way is something quite complicated and we don't want to bore you and ourselves with the details; but being practical, it is basically a convertion between the signal in time domain and its frequency domain components. Interestingly, this process is reversible and the other way around it is called IFFT ( I for Inverse , obviously...). Image credit: Smart Citizen In the example above, things in the time domain get a bit messy, but in the frequency domain we can clearly see the composition of two sine waves of the same amplitude of roughly 40Hz and 120Hz. The FFT algorithm hence helps us digest the information contained in a signal in a more visually understandable way. We will cover more details about the process and it's implementation in future sections. For this introduction, let's move on to what we actually want to do: the much anticipated weighting . At this point, our task is fairly easy: we just have to multiply both: our signal in the frequency domain with the weighting function and that's it! If we have a look at the figure below, in the time and frequency domain, the signals look like this: Image credit: Smart Citizen This example shows how our ears are only capable of perceiving the signal in red, but the actual sound components are in blue -- being much higher in the amplitude spectrum. If you want to get into the thick of it, here you have the actual implementation in Matlab of the A-weighting function that we'll use in the SCK V2.0. And finally, to close, let's take a look at the whole chain of processing, where we will continue in future sections: st= start: Signal acquisition e= end: RMS calculation op= operation: Windowing op2= operation: FFT op3= operation: Spectrum Normalisation op4= operation: Equalisation op5= operation: A-weighting st- op- op2- op3- op4- op5- e Image credit: Smart Citizen This is the whole signal treatment process we use for the I2S microphone ICS43432. We will have a look at windowing and its use in future sections, as well as its implementation in the SAMD21 Cortex M0+ for our firmware. NB NB : Being mathematical purist, there is yet another possibility for this procedure using convolution in time domain, which we will cover in future sections.","title":"RMS and FFT algorithm simplified"},{"location":"Components/Urban Sensor Board/Noise Sensor/#prepost-processing-signal-windowing-and-equalisation","text":"","title":"Pre/post processing: signal windowing and equalisation"},{"location":"Components/Urban Sensor Board/Noise Sensor/#signal-windowing","text":"In this section we are going to describe how we have to pre-post process our signals in order to obtain the results in the manner we are expecting. These are very important steps in our processing chain, since the FFT algorithms -or convolution FIR Filters- won't be able to cope with our system's limitations. These limitations might not be obvious at the beginning, but you really don't want to ignore them while designing your system, since they'll invalidate many of your measurements. If this sounds greek to you, consider reading Part I and Part II in this forum before continuing with this post. The very first of these limitations, is the fact that our microphone is, in fact, taking discrete samples of the ambient noise surrounding it. This means that, from the very beginning, we are missing some pieces of information and we will never be able to process them. But it's OK! For the purpose of our analysis, we don't need to sample continuosly and this situation is easily bypassed. Image credit: NUTAQ - Signal processing Discrete sampling has two main consequences for us: the first one is that we are taking samples once every 1/f_s 1/f_s , where f_s f_s is the sampling frequency. Normal audio systems sample at 44,1kHz, but this number might vary depending on the application. If you remember this chart , you might be wondering why we have to sample at such a high frequency. Image credit: Signal acquisition - Adinstruments This is due to the Nyquist sampling criterion , which states that at a minimum, we have to sample at double the maximum frequency we want to analyse . Since humans hearing has a limited frequency range that goes up to 20kHz in some cases, it is reasonable to use something around 40kHz. With this, the Nyquist criterion solves the so called aliasing problem , in which several sinusoid signals could fit the same sampling pattern if the number of samples is too low: Image credit: Wikipedia - Aliasing The second of the discrete sampling limitation comes from the amount of samples we are able to handle at a time . Normally, this is due to memory limitations in the RAM, although we'll see in the future where to allocate them. Nevertheless, it is not useful to handle buffers that are too long , since at some point, the increase of buffer length does not provide any additional information. Buffer length requirements in our case come from the minimum frequency we want to sample, which is around 20Hz . Doing some quick math, we need 0,05s worth of sample buffer, which at 44,1kHz is roughly 2200 samples . This is equally too many samples, considering that each could be allocated as a uint8_t , taking up to 16kB just for the raw buffer! This is where signal windowing kicks in. Imagine that we have a very-low-frequency sinusoid and that we are not able to sample completely the whole sine wave, due to buffer limitations. By definition, our system is assuming that the discrete samples we measure are constantly being repeated in the environment, one after the other: Image credit: Smart Citizen When we take the FFT of this signal, we see undesired frequencies that make our frequency spectrum invalid. This is called spectral leakage and it's mitigated by the use of windows (math funcions, not the OS). These windows operate by smoothing the edges of our measurement and preventing the jumps in the signal helping the FFT algorithm to properly analyse the signals. Image credit: Smart Citizen With the use of signal windowing , more specifically with the use of the hamming window , we are then able to reduce the amount of samples needed to roughly 1000 samples. Now we are down to 50% of the memory allocation needed without windowing . You can see the effect on the RMS relative errors in the image below, where the trend of the Hann (another common window) and the Hamming treated buffers, with respect to the frequency tends to stabilise much more quickly than the raw buffers. Image credit: Smart Citizen There is a wide range of functions to use and the decision depends on your application. For audio applications, the most common ones are the Hann, Hamming, and Blackmann. We chose the Hamming because it's trend is to stabilise a bit more quickly than the rest, although the differencies are minimal. For your reference, there is a very interesting description of all these phenomena in this article , where you'll find a more mathematical approach. Info Talk about the microphone response and how to correct it.","title":"Signal windowing"},{"location":"Components/Urban Sensor Board/Noise Sensor/#filtering-and-convolution","text":"In this section we are going to talk about a different approach to the FFT Analysis we have seen in previous sections. What if we don't like the FFT algorithm and we only want to obtain a dBA or dBC results? There is a fairly simple solution to this problem, and it's called filtering . Filtering is a very common technique in signal acquisition that eliminates some frequency components of the raw signal. Examples of filters you very likely have heard of are low-pass, high-pass and band-pass filters . These only let pass the low, high or a defined interval range of frequencies, mostly cancelling out the rest. In the frequency domain, they basicly multiply the spectrum of our signal with its filter spectrum. Exactly what we have done with the weighting. Image credit: Norwegian Creations First, it is important to get a glimpse of the math behind the filters and why they do their magic. And for this, the most important thing we need to know is called convolution . Image credit: River Trail For the purpose of audio analysis , let's consider we have an input vector, a filter kernel and an output vector. Our input vector can be the raw audio signal we have captured, being the output signal the result of the convolution operation. The filter kernel is the characteristic of the filter and will be, for this example, a one dimension array. What the convolution operation is going to do, in a very very very simplified way , is to sweep through the input sample and multiply each component with it's corresponding filter kernel component, then sum the results and put them in the corresponding output sample. If we put some math notation and call x[n] to the input vector, h[n] to the filter kernel and y[n] to the output vector, it all ends up looking like this: Image credit: DSP Guide Now, the most interesting thing of all this theory is that convolution and multiplication are equivalent operations when we jump from the time to the frequency domain . This means that multiplication in time domain equals to convolution in frequency domain, and more importantly for us, convolution in the time domain, equals to multiplication in the frequency domain . To sum up, the relationship between both domains would look like: Image credit: SmartCitizen Therefore, what we could do is to define a custom filter function and apply it via convolution to our input buffer. This is basically a FIR filter , where FIR stands for Finite Impulse Response . There is another type of filters called IIR , where IIR stands for Infinite impulse response . The difference between them is that FIR uses convolution and IIR uses recursion . The concept of recursion is very simple and it's nothing else than a simplification of the convolution, given that in the convolution algorithm, there are many recursive operations that we repeat over an over and we can implement into a smarter algorithm. Normally, IIR filters are more efficient in terms of speed and memory , but we need to specify a series of coefficients, and it's tricky, if not impossible, to create a custom filter response. Image credit: DSP Guide So finally! How can we avoid using the FFT algorithm to extract the desired frequency content of a signal and recreate the signal without it? Sounds complex, but now we know that we can use a FIR filter , with a custom frequency response and apply it via convolution to our input buffer. As simple as that. The custom frequency response, with the proper math, can be optained by applying the IFFT algorithm to the desired frequency response (for example, the A-weighting function). You can have a look to this example if you want to create a custom filter function in octave , with A or C weighting and implement it to a FIR filter in C++. Image credit: SmartCitizen Also, if you are really into it, you can read more about convolution and other DSP topics, we would recommended to go through this fantastic guide .","title":"Filtering and convolution"},{"location":"Components/Urban Sensor Board/Noise Sensor/#afsk-analyser","text":"In this section we are going to talk about a new feature we are planning to introduce in the upcoming version of the SCK: a FSK communication protocol via Audio (A-FSK). You might have read about this technique and it\u2019s usage in the Amazon Dash configuration process, and on the post today we are going to describe very briefly the work in progress for this feature. So! FSK stands for Frequency Shift Keying, which is a form of transmission through frequency variations on the carrying waveforms. It\u2019s major counterpart is the so called ASK, or Amplitude Shift Keying, in which the transmission is carried out via amplitude variations. A very simple form of ASK is OOK, which stands for On-Off-Keying, in which the amplitude of the carrier wave oscillates between a value and nothingness: Image credit: Electric Stack Exchange As in many other situations, there is a trade off between the options on the table: ASK or FSK? Maybe another one? The main disadvantage of ASK it is said to have a higher probability of error with respect to FSK, since noise interference affects amplitude of the transmitted wave. FSK, on the other hand, it is said to have a lower bandwidth efficiency. However, since we have talked about FFT quite a lot now, we thought FSK would be our best bet and also, because maybe bandwidth is not such a big deal after all as we can see below. Then, the idea is to implement an algorithm that is able to identify if the sound transmitted from an emitter (i.e. a smartphone) contains a series of reference frequencies in certain known spots. Following this principle, our aim is to transmit a byte per sound wave, hence, in a sound wave containing up to 8 possible carrier frequencies that might or not be activated. The activation (or not) of these frequencies in the analysed spectrum will yield a 1 or a 0, that we can use on a bit mask and extract 8-bit ASCII characters codes : Image credit: Martin Melhus The emitter could be based on the Web Audio API, as the example from Martin Melhus above from his project on a Web Audio Modem. Finally, the receiver would be our beloved I2S Mems microphone that we have been talking about for so long now, doing a FFT algorithm and detecting the peaks in it, identifying the carrier frequencies activation.","title":"AFSK Analyser"},{"location":"Components/Urban Sensor Board/Noise Sensor/#source-files_1","text":"Download Check the source code","title":"Source files"},{"location":"Sensor Analysis Framework/","text":"Sensor Analysis Framework Link The following section details the framework used for post processing the data in the iScape project. Based on Jupyter Notebooks and running Python and R , it is intended to provide a state-of-the-art data handling and analysis framework, which can be easily expanded due to it's flexibility and ease of use. All the files and notebooks related to this document can be found online in our Github repository: Check the source code Framework structure Link The structure of this framework can be split between two main areas: one dedicated to sensor data analysis and model generation; and an automated sensor correction script that recovers sensor data from the API, processes it, and posts it back to the API with the use of the results obtained in the data analysis. This structure is decribed in the following diagram: Furthermore, within the sensor data analysis, a notebook and several scripts are included, intended for modeling and data visualisation , including exploratory data analysis and a testing environment for sensor model calibration. This includes interfacing with the SmartCitizen API in order to download available sensors from the platform, as well as local csv analysis. Further functionalities are explained in the following sections. Data analysis notebook Link This notebook aims to provide the following features: An interface to either retrieve data from the Smart Citizen's API in a simple way or to load them from local sources (in csv format, compatible with the SCK SD card data) A data handling framework based on the well known Pandas package An exploratory data analysis interface to study sensor behaviour and correlations A flexible sensor calibration model interface with classical statistical methods such as linear regression, ARIMA, SARIMA-X among others, as well as more modern Machine Learning techniques with the use of LSTM (Long short term memory) networks and MLP (Multi Layer Perceptron) models for sequential data prediction and forecasting An interface to statistically validate and study the performance of these models, export and store them As a bonus, an interface to convert the python objects into the statistical analysis language R The framework also provides several functionalities within signal analysis field using numpy and scipy frameworks. An example of the workflow can be seen below: Loading in the data Link As mentioned, data can be downloaded from the SmartCitizen API with the KIT IDs or using local csv. In order to tidy up the data, the recordings are organised around the concept of test , an entity containing all the kits' references, sensors and general information regarding the conditions at which the measurements were carried out: Test Location, date and author Kit type and reference Sensor calibration data or reference Availability of reference equipment measurement and type A brief schema of the test structure is specified below: All this structure is filled up at the test creation with a dedicated script, saving future time to understand mismatching reading units, timestamps formats and so on. Finally, the devices' data is stored as Time Series data, with DateTime index in ISO8601 format. This is an important consideration for data visualisation and posterious modelling. An example from the API download can be seen in the below's image: Exploratory data analysis (WIP) Link The device's data can be quickly analysed using a simple interface in order to quickly select the desired channels and timeframes. Some of the functionalities already included are: Time Series visualisation Correlation plot and pairs plot Correlogram Heatmaps for geospatial data This section uses interactive plotting frameworks as Plotly and well know matplotlib to serve differente exploratory analysis tools: Data models (WIP) Link The data models section includes an easy to use and full interface to select data from different devices within a test in order to calibrate different models. Since the data is mainly based on Time Series analysis, it interfaces with common statistics and machine learning frameworks such as sci-kit learn , tensorflow , keras , and stats models . These frameworks provide tools to perform: Pre-processing stage: Outliers detection with Holt-Winters methods (triple exponential smoothing) Data study and analysis for multicollinearity and autocorrelation in order to determine significant variables and avoid model overfit with non-significant exogenous variables Trend decomposition and seasonality analysis Data split between training and test dataset, with the possibility of rolling prediction Model stage: Baseline model estimations in order to assess minimum targets for model quality (using naive regression models) Ordinary Linear Regression techniques for univariate and multivariate linear and non-linear independent variables ARIMA-X (Autorregresive, Integrated, Moving Average) models with exogenous variables using Box-Jenkis parameter selection methods More advanced machine learning techiques with RNN (Recurrent Neural Networks) for sequence predictions: MLP (MultiLayer Perceptron) model with basic RNN cells Single and multiple layers LSTM (Long-Thort Term Memory) networks with the possibility of including several shifted variables in the model training and prediction An example of the model is shown below for the estimation of the SGX4514 CO with the use of the rest of the Kit's available sensor, using a single layer LSTM network only two weeks of training: Depending on the model selected, different validation techniques are implemented, in order to verify models' assumptions and avoid data misinterpretation (i.e. Durbin Watson or Jacque Bera test for linear regression). Finally, it is important to follow carefully the instructions as stated in the notebook, in order to avoid low model quality. Model import/export and storage Link Once the model is analysed and validated, it can be saved and exported. This allows using the model in the future with the same variables in other sensor studies. The model objects are serialised with Pickle and can be uploaded to a git repository for later use. Source files Link Download Check the source code","title":"Index"},{"location":"Sensor Analysis Framework/#sensor-analysis-framework","text":"The following section details the framework used for post processing the data in the iScape project. Based on Jupyter Notebooks and running Python and R , it is intended to provide a state-of-the-art data handling and analysis framework, which can be easily expanded due to it's flexibility and ease of use. All the files and notebooks related to this document can be found online in our Github repository: Check the source code","title":"Sensor Analysis Framework"},{"location":"Sensor Analysis Framework/#framework-structure","text":"The structure of this framework can be split between two main areas: one dedicated to sensor data analysis and model generation; and an automated sensor correction script that recovers sensor data from the API, processes it, and posts it back to the API with the use of the results obtained in the data analysis. This structure is decribed in the following diagram: Furthermore, within the sensor data analysis, a notebook and several scripts are included, intended for modeling and data visualisation , including exploratory data analysis and a testing environment for sensor model calibration. This includes interfacing with the SmartCitizen API in order to download available sensors from the platform, as well as local csv analysis. Further functionalities are explained in the following sections.","title":"Framework structure"},{"location":"Sensor Analysis Framework/#data-analysis-notebook","text":"This notebook aims to provide the following features: An interface to either retrieve data from the Smart Citizen's API in a simple way or to load them from local sources (in csv format, compatible with the SCK SD card data) A data handling framework based on the well known Pandas package An exploratory data analysis interface to study sensor behaviour and correlations A flexible sensor calibration model interface with classical statistical methods such as linear regression, ARIMA, SARIMA-X among others, as well as more modern Machine Learning techniques with the use of LSTM (Long short term memory) networks and MLP (Multi Layer Perceptron) models for sequential data prediction and forecasting An interface to statistically validate and study the performance of these models, export and store them As a bonus, an interface to convert the python objects into the statistical analysis language R The framework also provides several functionalities within signal analysis field using numpy and scipy frameworks. An example of the workflow can be seen below:","title":"Data analysis notebook"},{"location":"Sensor Analysis Framework/#loading-in-the-data","text":"As mentioned, data can be downloaded from the SmartCitizen API with the KIT IDs or using local csv. In order to tidy up the data, the recordings are organised around the concept of test , an entity containing all the kits' references, sensors and general information regarding the conditions at which the measurements were carried out: Test Location, date and author Kit type and reference Sensor calibration data or reference Availability of reference equipment measurement and type A brief schema of the test structure is specified below: All this structure is filled up at the test creation with a dedicated script, saving future time to understand mismatching reading units, timestamps formats and so on. Finally, the devices' data is stored as Time Series data, with DateTime index in ISO8601 format. This is an important consideration for data visualisation and posterious modelling. An example from the API download can be seen in the below's image:","title":"Loading in the data"},{"location":"Sensor Analysis Framework/#exploratory-data-analysis-wip","text":"The device's data can be quickly analysed using a simple interface in order to quickly select the desired channels and timeframes. Some of the functionalities already included are: Time Series visualisation Correlation plot and pairs plot Correlogram Heatmaps for geospatial data This section uses interactive plotting frameworks as Plotly and well know matplotlib to serve differente exploratory analysis tools:","title":"Exploratory data analysis (WIP)"},{"location":"Sensor Analysis Framework/#data-models-wip","text":"The data models section includes an easy to use and full interface to select data from different devices within a test in order to calibrate different models. Since the data is mainly based on Time Series analysis, it interfaces with common statistics and machine learning frameworks such as sci-kit learn , tensorflow , keras , and stats models . These frameworks provide tools to perform: Pre-processing stage: Outliers detection with Holt-Winters methods (triple exponential smoothing) Data study and analysis for multicollinearity and autocorrelation in order to determine significant variables and avoid model overfit with non-significant exogenous variables Trend decomposition and seasonality analysis Data split between training and test dataset, with the possibility of rolling prediction Model stage: Baseline model estimations in order to assess minimum targets for model quality (using naive regression models) Ordinary Linear Regression techniques for univariate and multivariate linear and non-linear independent variables ARIMA-X (Autorregresive, Integrated, Moving Average) models with exogenous variables using Box-Jenkis parameter selection methods More advanced machine learning techiques with RNN (Recurrent Neural Networks) for sequence predictions: MLP (MultiLayer Perceptron) model with basic RNN cells Single and multiple layers LSTM (Long-Thort Term Memory) networks with the possibility of including several shifted variables in the model training and prediction An example of the model is shown below for the estimation of the SGX4514 CO with the use of the rest of the Kit's available sensor, using a single layer LSTM network only two weeks of training: Depending on the model selected, different validation techniques are implemented, in order to verify models' assumptions and avoid data misinterpretation (i.e. Durbin Watson or Jacque Bera test for linear regression). Finally, it is important to follow carefully the instructions as stated in the notebook, in order to avoid low model quality.","title":"Data models (WIP)"},{"location":"Sensor Analysis Framework/#model-importexport-and-storage","text":"Once the model is analysed and validated, it can be saved and exported. This allows using the model in the future with the same variables in other sensor studies. The model objects are serialised with Pickle and can be uploaded to a git repository for later use.","title":"Model import/export and storage"},{"location":"Sensor Analysis Framework/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/","text":"Introduction to Low Cost Air Quality Calibration Link Section under development The following section is currently a work in progress. Testing methodologies and calibration models Link 1.1. Field calibration of a cluster of low-cost available sensors for air quality monitoring. Part A: Ozone and nitrogen dioxide - Link Note on evaluation of calibration method The evaluation of sensor performances took into account hourly values. It was carried out using only values predicted by each calibration method. For each one, regression and difference-based analysis were conducted to evaluate their performance. These included the calculation of the coefficient of determination (R2),comparing the slope and intercept of the regression line with objective values of 1 and 0 respectively. The mean bias error (MBE)and the root mean squared error (RMSE) standardized with the standard deviation of the reference measurements were used to draw a target diagram [38].To assess the performance of each calibration method at individual air pollutant levels, we have also calculated the measurement uncertainty using orthogonal regression of the estimated outputs against reference data. This uncertainty was compared to the DQO for indicative method that corresponds to a rela-tive expanded uncertainty of 30% for O3 and 25% for NO 2 at the limit value set by the European Directive. The estimation method of the uncertainty, which corresponds to the relative expanded uncertainty Ur, was carried out using Eq. (1) where b0 and b1 are the slope and intercept of the orthogonal regression and RSS the sum of square of residuals is calculated using Eq. (2). Note on correlation : An important aspect of the dataset is the lack of independence between parameters. Usually, O3 is highly correlated with temperature and anti-correlated with relative humidity and CO2 and to alower extent with CO and NO 2 . As a consequence, it will be difficult to estimate O3 correctly using temperature, relative humidity and CO2 as estimators. Note on field deployment Theses multi-sensors were either calibrated against standard gas mixtures or using artificial neural network under field conditions. The latter method resulted in mixed results either satisfactory for short periods or generally weak for longer data series . Note on drift over time Finally the drift over time of each calibration methods was plot-ted in order to evidence general trends. To ease the detection ofpossible patterns by filtering noise, the daily residuals were plottedbetween reference measurements and sensor predictions ratherthan the hourly ones. Note for number of sensors : One shall remember that implementing the ANN-MLR requires a set of 7 sensors, of which 2 NO 2 MOx and 2 NO 2 electrochemical sensors, 1 O3 electrochemical sensor, 1 CO electrochemical sensor and absolute humidity(therefore temperature and relative humidity sensor). Moreover,all gas sensors were previously calibrated using correction models (Table 2) including reference measurements for O3. 1.2. Field calibration of a cluster of low-cost commercially availablesensors for air quality monitoring. Part B: NO, CO and CO2 - Link Note on target diagram and stats Better explained below (06) Fig. 3 gives the target diagram for LR, MLR and ANNs calibration methods for NO (green), CO (red) and CO2(black). The target diagram is used for evaluating sensor data against reference measurements. This diagram is an evolution of the Taylor diagram, which was based on the geometrical relation between the Centred Root Mean Square Error (CRMSE) and the standard deviation of both reference (RM) and sensor data (S). The target diagram allows to extend the notion of the Taylor diagram by distinguishing the root Mean Square Error (RMSE) within the contributions from (a) the Mean Bias Error (MBE) and (b) the CRMSE (see Eqs. (1)\u2013(3)).MBE and CRMSE values are gathered in Tables 4 and 5. This plot represents the normalised RMSE as the quadratic sum of the normalised MBE on the Y-axis versus the normalised CRMSE on the x-axis. The distance between each point and the origin represents the normalised RMSE for each platform sensor. Furthermore, target scores are plotted in the left quadrant of the diagram when the standard deviation of the sensor responses is lower than the one of the references measurements and conversely. In the original approach of the target diagram, RMSE, MBE and CRMSE can be normalised using the standard deviation of the reference measurements (RM). Sensors with random error equivalent to the variance of the observations stand in the circle area of radius 1. Target scores inside this circle indicate a variance of the residuals between sensor and reference measurement equal or lower than the variance of the reference measurements. In fact, sensors within the target circle are better predictors for the reference measurements than mean concentrations over the whole sampling period. Note on measurement span For the CO sensors, even though ANNs methods were found by far to be the most efficient methods, all calibration methods produced RMSEs falling outside the target circle. This evidenced a lack of agreement between CO sensor values and reference measurements . Our first guess is that this situation was primarily caused by the limited range of CO level at the test site (50% of data in a range of less than 0.2 umol/mol) which did not allow a correct fit of the calibration function. 2. Sensors 2017, 17, 1653 - Link Notes on baseline resistance spread The consequence of this model is that the sensor\u2019s response is only partially a function of the amount of gas to which the surface is exposed. Instead, the sensor will have a baseline resistance that is related to the bulk and particle boundary resistance. Because of the random geometry of the granular sensor surface, the baseline resistance will vary between individual sensors . Notes on cross-sensitivity Although the deployment of multiple different sensors can compensate for the cross-sensitivity issues in calibration, it cannot eliminate it. MOS sensors can thus be used only in situations where any interfering species can either be measured by other means, or they must be calibrated regularly and used in locations where the background varies in concentration slowly compared with the target gases . Notes on target accuracy The target accuracy at 95% confidence is 20\u03bcg/m3 for both NO_2 NO_2 European directives define target and absolute maximum thresholds for the concentration of both these gases. For NO_2 NO_2 , the maximum average yearly concentration is 40 \u03bcg/m3 and hourly concentrations must not exceed 200 \u03bcg/m3 more than eighteen times a year. For O_3 O_3 , the daily 8-h mean must not exceed 120 \u03bcg/m3 more than 25 times over three years. Urban environments frequently experience NO 2 levels that exceed the yearly target. An accuracy of 20\u03bcg/m3 would provide enough resolution to make these sensors a useful supplement to modelling and satellite campaigns, in the context of these targets. Notes on mounting and flow (we have reproduced this issue) An important practical consideration with any in situ air quality sensor design is ensuring adequate flow of sampling air through the device. Stale air inside a casing will produce unrepresentative results , and even sensors mounted outside a casing might not get a properly-mixed sample. Note on calibration time and fit selection Even with the use of these techniques, the phenomenon of sensor drift was not corrected for here, and it truncated trustworthy results to data to within four months from calibration. This is a similar scale as has been reported by Spinelle et al. and Masson et al. and somewhat of an improvement over the results described in the former. An analytical approach to counteracting this drift might be \"merging calibrations\", where a sensor is calibrated at the start and end of a four-month campaign, and the coefficients gradually change from one end of the experiment run to the other. Notes on ageing Further to this, it is clear that there are two major factors in the longevity of a sensor\u2019s calibration. The first is the natural degradation of the heater element, which becomes hotter over prolonged use [15] and causes the sensor\u2019s response profile to vary. The second is the effect of slowly-varying interfering gases, which over the course of months shift the sensor\u2019s baseline. The first problem may have an engineering solution, but the second will involve taking the results of the tests in an artificial atmosphere, identifying the most critical species and either measuring or possibly modelling their likely concentrations during deployments. Note on packaging testing The calibration setup for the sensors is not currently optimal, but the strong correlation of sensor voltages within the same housing suggests a solution in ensuring that the same packet of air reaches the MOS sensors as the reference instrument, in as little time as possible . The rapid rate at which NOx compounds evolve and the sensitivity of the Leighton system to sunlight means that the representativity of the calibration environment is even more critical than it would be for more specific sensors. 3. Christian Kj\u00e6r Jensen - Assessing the applicability of low-cost electrochemical gas sensors for urban air quality monitoring. Master\u2019s thesis. January 2016 4. Practical field calibration of electrochemical NO 2 sensors for urban air quality applications Note on influence of T-H O3 on AlphaSense As all electrochemical NO 2 sensors, the Alphasense NO 2 -B4 sensor is not very selective to the target gas. The sensor response can best be explained as a linear combination of NO 2 , O3, temperature and humidity signals ( R^2\u2248 0.9 R^2\u2248 0.9 ). As a consequence, a linear combination of the Working Electrode and the Auxiliary Electrode alone give poor indication of ambient NO 2 concentrations. The accuracy varies greatly between different sensors ( R^2 R^2 between 0.3 and 0.7). For the Urban AirQ campaign, temperature and relative humidity were included in a multilinear regression approach. The results improve significantly with R^2 R^2 values typically around 0.8. This corresponds well with the findings of Jiao et al. (2016), who find an adjusted R^2=0.82 R^2=0.82 for the best performing electrochemical NO 2 sensor in their evaluation, when including T and RH. Best results are obtained by also including ozone measurements in the calibration model: R2 increases to 0.9. Spinelle et al. (2015b) used a similar regression and found R^2 R^2 ranging from 0.35 to 0.77 for 4 electrochemical NO 2 sensors during a two week calibration period, but dropping to 0.03\u20140.08 when applied to a successive 5-month validation period. Low NO 2 values at their semi-rural site partly explains this poor performance, but most likely also unaccounted effects such as changing sensor sensitivity and signal drift. 5. Mobile sensor network noise reduction and recalibration using a Bayesian network The related work can be placed in three categories: colocated sensor calibration, sensor abnormality detection, and Bayesian network based approaches. Colocated : Those techniques require that the co-located sensors are of the same type and thus should have the same response from the physical environment. In contrast to the previous work, our technique can work on mobile sensing devices containing various types of metal oxide sensors. Sensor Abnormality : crap Bayesian Networks : Mola Other readings Link Masson, N.; Piedrahita, R.; Hannigan, M. Approach for quantification of metal oxide type semiconductor gas sensors used for ambient air quality monitoring. Sens. Actuators B Chem. 2015, 208, 339\u2013345. Piedrahita, R.; Xiang, Y.; Masson, N.; Ortega, J.; Collier, A.; Jiang, Y.; Li, K.; Dick, R.; Lv, Q.; Hannigan, M.; et al. The next generation of low-cost personal air quality sensors for quantitative exposure monitoring. Atmos. Meas. Tech. 2014, 7, 3325\u20133336. Assessment of air quality microsensors versus reference methods: The EuNetAir joint exercise - Link GUIDE TO THE DEMONSTRATION OF EQUIVALENCE OF AMBIENT AIR MONITORING METHODS - Link Testing and calibration Link We can split the sensor testing into this sequence (for both mics and alphasense ): 1. Characterisation : Base testing for assessing general sensor response, stabilisation time or operational modes 2. Calibration : Assess actual concentration functions once we know how to operate the sensor itself. Include other factors such as environmental effects, cross-sensitivity, etc. Note : sensor calibrations from alphasense is all in here . Characterisation Testing Link Mics Link Basic - Sensor response - Sensor limits (baseline and max reading) - Heating time and stabilisation time Advanced - Humidity and temperature (probably not to be donee on the chamber) - Pulse Mode operation Alphasense Link Questions to answer: Is the Sensitivity varying with temperature (YES) - Ask alphasense for data. Is the reading varying with temperature (WDK) - Ask alphasense and calibrate on our own Do we want to input the zero currents measured as offset on our boards? Furthermore - Do they change with time / temperature / humidity? (NO/NO/NO) Basic Measure Zero currents and check if n is the same with what alphasense's giving us Measure convertion factor between nA/mV with Jano's tester board Ask alphasense for: Sensitivity variation over time Sensitvity variation with temperature/humidity Zero currents / offset variation with temperature/humidity Advanced - Long term deployment with colocation in: - Barcelona? - Alphasense? - iScape? Calibration Link We could divide it in two stages, depending on how the results turn out to be: 1. chamber testing* for determining f functions and 2. outdoor testing* for checking g and h functions: Concentration = f(SensorParams, T, H) + g(T,H) + h(Others) Concentration = f(SensorParams, T, H) + g(T,H) + h(Others) Chamber testing Link Mics We need to characterise several sensor parameters. The sensor response is apparently something like: log_{10}(Concentration) = f(Rs, Ro) = \\beta_1+\\beta_2 log_{10}(Rs/Ro) log_{10}(Concentration) = f(Rs, Ro) = \\beta_1+\\beta_2 log_{10}(Rs/Ro) Where: - Rs is the sensor response - Ro is the baseline resistance, normally at Zero air - \\beta \\beta s are log linear correlation coefficients (from SGX AAN) Info This is based on SGX datasheet: The f function must be calibrated and the baseline resistance needs to be monitored through the sensor sensitivity. SGX defines the sensitivity as: Sensitivity_{CO} = {Ro_{pure-air} \\over Rs_{60ppm-CO}} Sensitivity_{CO} = {Ro_{pure-air} \\over Rs_{60ppm-CO}} Sensitivity_{NO_2} = {Rs_{0.25ppm-NO_2} \\over Ro_{pure-air}} Sensitivity_{NO_2} = {Rs_{0.25ppm-NO_2} \\over Ro_{pure-air}} With CO measured at 23\u00baC 50%RH and NO 2 at 23\u00baC and 5%RH. However, due to hardware and testing limitations, we could monitor our own sensitivity defined as: Sensitivity_{CO} = {Rs_{pure-air} \\over Rs_{50ppm-CO}} Sensitivity_{CO} = {Rs_{pure-air} \\over Rs_{50ppm-CO}} Sensitivity_{NO_2} = {Rs_{10ppm-NO_2} \\over Rs_{pure-air}} Sensitivity_{NO_2} = {Rs_{10ppm-NO_2} \\over Rs_{pure-air}} Both at 23\u00baC and 50%RH. With this, we should be able to monitor the sensor sensitivity in controlled conditions so that we can assess the shape of the f(Rs,Ro) component of the calibration. Define pre and post exposure tests in order to find what the Sensitivity variation is and re-calculate gas concentrations based on Rs readings. Alphasense NA : If alphasense provides us with all this data , we could skip this characterisation: although we should verify some of the data with random batches. After having characterised PCB settings, we need to obtain the factor n in this formula: Concentration = {I_{WE}-n(I_{AE}) \\over Sensitivity(T,H)} + g(T,H) + h(Others) Concentration = {I_{WE}-n(I_{AE}) \\over Sensitivity(T,H)} + g(T,H) + h(Others) For this we need to test for the relationship between working and auxiliary electrodes currents relationship with zero air testing : 20min good flow of zero air for all three sensors. Also, ideally, the sensor current is directly proportional to: I_L = k C_T I_L = k C_T In controlled conditions. Therefore, we need to assess this value and with it the f function. Combined testing Link For both sensors, it would be desirable to assess the models including sensor reading, T, H and other sensor data for cross-sensitivity and their uncertainty. These are the g and h functions and they should be based on additional sensor data for reference. Reference sensor possibilities: outdoor with other reference sensors iScape sensing campaigns or more indoor testing with more calibrated gas bottles (expensive, not a good approach) We also need to check how the sensor behaves in a temporal manner : Repeteability Short term drift Long term drift Proposal: Inchamber - Outdoor testing sequences Using any of the above references, perform in-chamber with bottles + outdoor exposure with reference , in-chamber with bottles testing. Vary exposure time to uncontrolled pollutants and conditions and recenter data with calibration bottles to understand: - How the sensor drifts in short and long term - What's the longest time we can test in uncontrolled exposure - Identify if we can extract data from calibration chamber and prioritise it in the modelling Calibration and modelling is reviewed below. Calibration and model notes Link For the outdoor exposure time, we need to understand how the sensor is exposed in an uncontrolled environment. We need to answer these questions: **Are the readings multicollinear ?**: do several sensor readings could be correlated with others and therefore not prioritised in our model? Are the readings heteroscedastic : does the sensor reading vary in the different measurement conditions? Is it likely that we will overfit data? Is it likely that sensor readings in different conditions would have different variabilities? Are we going to be calibrate with a small amount of observations vs number of variables (T, H, sensor readings mics (CO, NO 2 ), aS (O3 + NO 2 , NO 2 , CO))? If so, we should then use reference sensors: Check regularisation techniques: Lasso / Ridge to reduce model complexity Check PCR or PLS for feature extraction: create different principal components that are not multicollinear (but depend on other variables) If dependent variable is continuous and model is suffering from collinearity or there are a lot of independent variables: PCR, PLS, ridge, lasso and elastic net regressions. Then select the final model based on Adjusted R-Square, RMSE, AIC and BIC.","title":"Low Cost Sensors Calibration"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#introduction-to-low-cost-air-quality-calibration","text":"Section under development The following section is currently a work in progress.","title":"Introduction to Low Cost Air Quality Calibration"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#testing-methodologies-and-calibration-models","text":"1.1. Field calibration of a cluster of low-cost available sensors for air quality monitoring. Part A: Ozone and nitrogen dioxide - Link Note on evaluation of calibration method The evaluation of sensor performances took into account hourly values. It was carried out using only values predicted by each calibration method. For each one, regression and difference-based analysis were conducted to evaluate their performance. These included the calculation of the coefficient of determination (R2),comparing the slope and intercept of the regression line with objective values of 1 and 0 respectively. The mean bias error (MBE)and the root mean squared error (RMSE) standardized with the standard deviation of the reference measurements were used to draw a target diagram [38].To assess the performance of each calibration method at individual air pollutant levels, we have also calculated the measurement uncertainty using orthogonal regression of the estimated outputs against reference data. This uncertainty was compared to the DQO for indicative method that corresponds to a rela-tive expanded uncertainty of 30% for O3 and 25% for NO 2 at the limit value set by the European Directive. The estimation method of the uncertainty, which corresponds to the relative expanded uncertainty Ur, was carried out using Eq. (1) where b0 and b1 are the slope and intercept of the orthogonal regression and RSS the sum of square of residuals is calculated using Eq. (2). Note on correlation : An important aspect of the dataset is the lack of independence between parameters. Usually, O3 is highly correlated with temperature and anti-correlated with relative humidity and CO2 and to alower extent with CO and NO 2 . As a consequence, it will be difficult to estimate O3 correctly using temperature, relative humidity and CO2 as estimators. Note on field deployment Theses multi-sensors were either calibrated against standard gas mixtures or using artificial neural network under field conditions. The latter method resulted in mixed results either satisfactory for short periods or generally weak for longer data series . Note on drift over time Finally the drift over time of each calibration methods was plot-ted in order to evidence general trends. To ease the detection ofpossible patterns by filtering noise, the daily residuals were plottedbetween reference measurements and sensor predictions ratherthan the hourly ones. Note for number of sensors : One shall remember that implementing the ANN-MLR requires a set of 7 sensors, of which 2 NO 2 MOx and 2 NO 2 electrochemical sensors, 1 O3 electrochemical sensor, 1 CO electrochemical sensor and absolute humidity(therefore temperature and relative humidity sensor). Moreover,all gas sensors were previously calibrated using correction models (Table 2) including reference measurements for O3. 1.2. Field calibration of a cluster of low-cost commercially availablesensors for air quality monitoring. Part B: NO, CO and CO2 - Link Note on target diagram and stats Better explained below (06) Fig. 3 gives the target diagram for LR, MLR and ANNs calibration methods for NO (green), CO (red) and CO2(black). The target diagram is used for evaluating sensor data against reference measurements. This diagram is an evolution of the Taylor diagram, which was based on the geometrical relation between the Centred Root Mean Square Error (CRMSE) and the standard deviation of both reference (RM) and sensor data (S). The target diagram allows to extend the notion of the Taylor diagram by distinguishing the root Mean Square Error (RMSE) within the contributions from (a) the Mean Bias Error (MBE) and (b) the CRMSE (see Eqs. (1)\u2013(3)).MBE and CRMSE values are gathered in Tables 4 and 5. This plot represents the normalised RMSE as the quadratic sum of the normalised MBE on the Y-axis versus the normalised CRMSE on the x-axis. The distance between each point and the origin represents the normalised RMSE for each platform sensor. Furthermore, target scores are plotted in the left quadrant of the diagram when the standard deviation of the sensor responses is lower than the one of the references measurements and conversely. In the original approach of the target diagram, RMSE, MBE and CRMSE can be normalised using the standard deviation of the reference measurements (RM). Sensors with random error equivalent to the variance of the observations stand in the circle area of radius 1. Target scores inside this circle indicate a variance of the residuals between sensor and reference measurement equal or lower than the variance of the reference measurements. In fact, sensors within the target circle are better predictors for the reference measurements than mean concentrations over the whole sampling period. Note on measurement span For the CO sensors, even though ANNs methods were found by far to be the most efficient methods, all calibration methods produced RMSEs falling outside the target circle. This evidenced a lack of agreement between CO sensor values and reference measurements . Our first guess is that this situation was primarily caused by the limited range of CO level at the test site (50% of data in a range of less than 0.2 umol/mol) which did not allow a correct fit of the calibration function. 2. Sensors 2017, 17, 1653 - Link Notes on baseline resistance spread The consequence of this model is that the sensor\u2019s response is only partially a function of the amount of gas to which the surface is exposed. Instead, the sensor will have a baseline resistance that is related to the bulk and particle boundary resistance. Because of the random geometry of the granular sensor surface, the baseline resistance will vary between individual sensors . Notes on cross-sensitivity Although the deployment of multiple different sensors can compensate for the cross-sensitivity issues in calibration, it cannot eliminate it. MOS sensors can thus be used only in situations where any interfering species can either be measured by other means, or they must be calibrated regularly and used in locations where the background varies in concentration slowly compared with the target gases . Notes on target accuracy The target accuracy at 95% confidence is 20\u03bcg/m3 for both NO_2 NO_2 European directives define target and absolute maximum thresholds for the concentration of both these gases. For NO_2 NO_2 , the maximum average yearly concentration is 40 \u03bcg/m3 and hourly concentrations must not exceed 200 \u03bcg/m3 more than eighteen times a year. For O_3 O_3 , the daily 8-h mean must not exceed 120 \u03bcg/m3 more than 25 times over three years. Urban environments frequently experience NO 2 levels that exceed the yearly target. An accuracy of 20\u03bcg/m3 would provide enough resolution to make these sensors a useful supplement to modelling and satellite campaigns, in the context of these targets. Notes on mounting and flow (we have reproduced this issue) An important practical consideration with any in situ air quality sensor design is ensuring adequate flow of sampling air through the device. Stale air inside a casing will produce unrepresentative results , and even sensors mounted outside a casing might not get a properly-mixed sample. Note on calibration time and fit selection Even with the use of these techniques, the phenomenon of sensor drift was not corrected for here, and it truncated trustworthy results to data to within four months from calibration. This is a similar scale as has been reported by Spinelle et al. and Masson et al. and somewhat of an improvement over the results described in the former. An analytical approach to counteracting this drift might be \"merging calibrations\", where a sensor is calibrated at the start and end of a four-month campaign, and the coefficients gradually change from one end of the experiment run to the other. Notes on ageing Further to this, it is clear that there are two major factors in the longevity of a sensor\u2019s calibration. The first is the natural degradation of the heater element, which becomes hotter over prolonged use [15] and causes the sensor\u2019s response profile to vary. The second is the effect of slowly-varying interfering gases, which over the course of months shift the sensor\u2019s baseline. The first problem may have an engineering solution, but the second will involve taking the results of the tests in an artificial atmosphere, identifying the most critical species and either measuring or possibly modelling their likely concentrations during deployments. Note on packaging testing The calibration setup for the sensors is not currently optimal, but the strong correlation of sensor voltages within the same housing suggests a solution in ensuring that the same packet of air reaches the MOS sensors as the reference instrument, in as little time as possible . The rapid rate at which NOx compounds evolve and the sensitivity of the Leighton system to sunlight means that the representativity of the calibration environment is even more critical than it would be for more specific sensors. 3. Christian Kj\u00e6r Jensen - Assessing the applicability of low-cost electrochemical gas sensors for urban air quality monitoring. Master\u2019s thesis. January 2016 4. Practical field calibration of electrochemical NO 2 sensors for urban air quality applications Note on influence of T-H O3 on AlphaSense As all electrochemical NO 2 sensors, the Alphasense NO 2 -B4 sensor is not very selective to the target gas. The sensor response can best be explained as a linear combination of NO 2 , O3, temperature and humidity signals ( R^2\u2248 0.9 R^2\u2248 0.9 ). As a consequence, a linear combination of the Working Electrode and the Auxiliary Electrode alone give poor indication of ambient NO 2 concentrations. The accuracy varies greatly between different sensors ( R^2 R^2 between 0.3 and 0.7). For the Urban AirQ campaign, temperature and relative humidity were included in a multilinear regression approach. The results improve significantly with R^2 R^2 values typically around 0.8. This corresponds well with the findings of Jiao et al. (2016), who find an adjusted R^2=0.82 R^2=0.82 for the best performing electrochemical NO 2 sensor in their evaluation, when including T and RH. Best results are obtained by also including ozone measurements in the calibration model: R2 increases to 0.9. Spinelle et al. (2015b) used a similar regression and found R^2 R^2 ranging from 0.35 to 0.77 for 4 electrochemical NO 2 sensors during a two week calibration period, but dropping to 0.03\u20140.08 when applied to a successive 5-month validation period. Low NO 2 values at their semi-rural site partly explains this poor performance, but most likely also unaccounted effects such as changing sensor sensitivity and signal drift. 5. Mobile sensor network noise reduction and recalibration using a Bayesian network The related work can be placed in three categories: colocated sensor calibration, sensor abnormality detection, and Bayesian network based approaches. Colocated : Those techniques require that the co-located sensors are of the same type and thus should have the same response from the physical environment. In contrast to the previous work, our technique can work on mobile sensing devices containing various types of metal oxide sensors. Sensor Abnormality : crap Bayesian Networks : Mola","title":"Testing methodologies and calibration models"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#other-readings","text":"Masson, N.; Piedrahita, R.; Hannigan, M. Approach for quantification of metal oxide type semiconductor gas sensors used for ambient air quality monitoring. Sens. Actuators B Chem. 2015, 208, 339\u2013345. Piedrahita, R.; Xiang, Y.; Masson, N.; Ortega, J.; Collier, A.; Jiang, Y.; Li, K.; Dick, R.; Lv, Q.; Hannigan, M.; et al. The next generation of low-cost personal air quality sensors for quantitative exposure monitoring. Atmos. Meas. Tech. 2014, 7, 3325\u20133336. Assessment of air quality microsensors versus reference methods: The EuNetAir joint exercise - Link GUIDE TO THE DEMONSTRATION OF EQUIVALENCE OF AMBIENT AIR MONITORING METHODS - Link","title":"Other readings"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#testing-and-calibration","text":"We can split the sensor testing into this sequence (for both mics and alphasense ): 1. Characterisation : Base testing for assessing general sensor response, stabilisation time or operational modes 2. Calibration : Assess actual concentration functions once we know how to operate the sensor itself. Include other factors such as environmental effects, cross-sensitivity, etc. Note : sensor calibrations from alphasense is all in here .","title":"Testing and calibration"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#characterisation-testing","text":"","title":"Characterisation Testing"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#mics","text":"Basic - Sensor response - Sensor limits (baseline and max reading) - Heating time and stabilisation time Advanced - Humidity and temperature (probably not to be donee on the chamber) - Pulse Mode operation","title":"Mics"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#alphasense","text":"Questions to answer: Is the Sensitivity varying with temperature (YES) - Ask alphasense for data. Is the reading varying with temperature (WDK) - Ask alphasense and calibrate on our own Do we want to input the zero currents measured as offset on our boards? Furthermore - Do they change with time / temperature / humidity? (NO/NO/NO) Basic Measure Zero currents and check if n is the same with what alphasense's giving us Measure convertion factor between nA/mV with Jano's tester board Ask alphasense for: Sensitivity variation over time Sensitvity variation with temperature/humidity Zero currents / offset variation with temperature/humidity Advanced - Long term deployment with colocation in: - Barcelona? - Alphasense? - iScape?","title":"Alphasense"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#calibration","text":"We could divide it in two stages, depending on how the results turn out to be: 1. chamber testing* for determining f functions and 2. outdoor testing* for checking g and h functions: Concentration = f(SensorParams, T, H) + g(T,H) + h(Others) Concentration = f(SensorParams, T, H) + g(T,H) + h(Others)","title":"Calibration"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#chamber-testing","text":"Mics We need to characterise several sensor parameters. The sensor response is apparently something like: log_{10}(Concentration) = f(Rs, Ro) = \\beta_1+\\beta_2 log_{10}(Rs/Ro) log_{10}(Concentration) = f(Rs, Ro) = \\beta_1+\\beta_2 log_{10}(Rs/Ro) Where: - Rs is the sensor response - Ro is the baseline resistance, normally at Zero air - \\beta \\beta s are log linear correlation coefficients (from SGX AAN) Info This is based on SGX datasheet: The f function must be calibrated and the baseline resistance needs to be monitored through the sensor sensitivity. SGX defines the sensitivity as: Sensitivity_{CO} = {Ro_{pure-air} \\over Rs_{60ppm-CO}} Sensitivity_{CO} = {Ro_{pure-air} \\over Rs_{60ppm-CO}} Sensitivity_{NO_2} = {Rs_{0.25ppm-NO_2} \\over Ro_{pure-air}} Sensitivity_{NO_2} = {Rs_{0.25ppm-NO_2} \\over Ro_{pure-air}} With CO measured at 23\u00baC 50%RH and NO 2 at 23\u00baC and 5%RH. However, due to hardware and testing limitations, we could monitor our own sensitivity defined as: Sensitivity_{CO} = {Rs_{pure-air} \\over Rs_{50ppm-CO}} Sensitivity_{CO} = {Rs_{pure-air} \\over Rs_{50ppm-CO}} Sensitivity_{NO_2} = {Rs_{10ppm-NO_2} \\over Rs_{pure-air}} Sensitivity_{NO_2} = {Rs_{10ppm-NO_2} \\over Rs_{pure-air}} Both at 23\u00baC and 50%RH. With this, we should be able to monitor the sensor sensitivity in controlled conditions so that we can assess the shape of the f(Rs,Ro) component of the calibration. Define pre and post exposure tests in order to find what the Sensitivity variation is and re-calculate gas concentrations based on Rs readings. Alphasense NA : If alphasense provides us with all this data , we could skip this characterisation: although we should verify some of the data with random batches. After having characterised PCB settings, we need to obtain the factor n in this formula: Concentration = {I_{WE}-n(I_{AE}) \\over Sensitivity(T,H)} + g(T,H) + h(Others) Concentration = {I_{WE}-n(I_{AE}) \\over Sensitivity(T,H)} + g(T,H) + h(Others) For this we need to test for the relationship between working and auxiliary electrodes currents relationship with zero air testing : 20min good flow of zero air for all three sensors. Also, ideally, the sensor current is directly proportional to: I_L = k C_T I_L = k C_T In controlled conditions. Therefore, we need to assess this value and with it the f function.","title":"Chamber testing"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#combined-testing","text":"For both sensors, it would be desirable to assess the models including sensor reading, T, H and other sensor data for cross-sensitivity and their uncertainty. These are the g and h functions and they should be based on additional sensor data for reference. Reference sensor possibilities: outdoor with other reference sensors iScape sensing campaigns or more indoor testing with more calibrated gas bottles (expensive, not a good approach) We also need to check how the sensor behaves in a temporal manner : Repeteability Short term drift Long term drift Proposal: Inchamber - Outdoor testing sequences Using any of the above references, perform in-chamber with bottles + outdoor exposure with reference , in-chamber with bottles testing. Vary exposure time to uncontrolled pollutants and conditions and recenter data with calibration bottles to understand: - How the sensor drifts in short and long term - What's the longest time we can test in uncontrolled exposure - Identify if we can extract data from calibration chamber and prioritise it in the modelling Calibration and modelling is reviewed below.","title":"Combined testing"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#calibration-and-model-notes","text":"For the outdoor exposure time, we need to understand how the sensor is exposed in an uncontrolled environment. We need to answer these questions: **Are the readings multicollinear ?**: do several sensor readings could be correlated with others and therefore not prioritised in our model? Are the readings heteroscedastic : does the sensor reading vary in the different measurement conditions? Is it likely that we will overfit data? Is it likely that sensor readings in different conditions would have different variabilities? Are we going to be calibrate with a small amount of observations vs number of variables (T, H, sensor readings mics (CO, NO 2 ), aS (O3 + NO 2 , NO 2 , CO))? If so, we should then use reference sensors: Check regularisation techniques: Lasso / Ridge to reduce model complexity Check PCR or PLS for feature extraction: create different principal components that are not multicollinear (but depend on other variables) If dependent variable is continuous and model is suffering from collinearity or there are a lot of independent variables: PCR, PLS, ridge, lasso and elastic net regressions. Then select the final model based on Adjusted R-Square, RMSE, AIC and BIC.","title":"Calibration and model notes"},{"location":"Sensor Analysis Framework/guides/Install the framework/","text":"How to install the framework Link The following data analysis framework is built on Python 2.7 and Jupyter Notebooks. Here we will show you how to install it: Dowload and Install Anaconda for Python 2.7 https://www.continuum.io/downloads Visit Github to download the project folder or simply use git . Open the Anaconda Navigator app and launch the Jupyter Notebook . Using the Jupyter Notebook website browse your computer to find the project folder. Ready Go and check How to use the notebook Learn More Still wondering what this is? Read this introduction to Jupyter Advanced Installation If you are already familiar with Python and you like to avoid installing Anaconda and follow the Advanced users installation Worried about your existing Python? Do you have already a Python environment you use for other work and you are worried about updating some packages? Learn how to load a dedicated environment Advanced installation features Link How to run the project isolated from your Python environment Link Do you have already a Python environment you use for other work and you are worried about updating some packages? Conda can load a dedicated environment for you to run Python and Jupyter based on the environment.yml configuration file we provide. Open your favourite shell on the directory you have your project. ( cmd.exe on windows) Run the following commands: This will install and load the Python environment we prepared for iSCAPE conda env create -f environment.yml Now activate the environment source activate iscape Ready, run to run Jupyter jupyter notebook Advanced users installation Link If you do not want to install Anaconda you can install all the dependencies manually. Just follow the steps above: Install Python Link Python is the main programming language we will use for Data Analysis. On Windows download and run the installer for Python 2.7 Mac cames directly with python built in. However you can install the latest version using Hombrew and then run $ brew install python On Linux simply use your distribution package manager like $ apt in Debian or Ubuntu. Install Pip Link Pip is the packet manager Python uses and it comes installed by default. If you have any issues you can download pip here . Installl Jupyter Link Jupyter Notebooks allows us to quickly learn, develop and improve our tools by providing a common convenient framework and UI. Simply run pip install jupyter on your terminal to install it. Download the source Link Download from Github or simply use git git clone https://github.com/fablabbcn/smartcitizen-iscape-data.git Run the notebook Link On your terminal go to the folder where tou downloaded your files and then run jupyter notebook this will open a new webpage and you will be available to run your code there.","title":"Install the framework"},{"location":"Sensor Analysis Framework/guides/Install the framework/#how-to-install-the-framework","text":"The following data analysis framework is built on Python 2.7 and Jupyter Notebooks. Here we will show you how to install it: Dowload and Install Anaconda for Python 2.7 https://www.continuum.io/downloads Visit Github to download the project folder or simply use git . Open the Anaconda Navigator app and launch the Jupyter Notebook . Using the Jupyter Notebook website browse your computer to find the project folder. Ready Go and check How to use the notebook Learn More Still wondering what this is? Read this introduction to Jupyter Advanced Installation If you are already familiar with Python and you like to avoid installing Anaconda and follow the Advanced users installation Worried about your existing Python? Do you have already a Python environment you use for other work and you are worried about updating some packages? Learn how to load a dedicated environment","title":"How to install the framework"},{"location":"Sensor Analysis Framework/guides/Install the framework/#advanced-installation-features","text":"","title":"Advanced installation features"},{"location":"Sensor Analysis Framework/guides/Install the framework/#how-to-run-the-project-isolated-from-your-python-environment","text":"Do you have already a Python environment you use for other work and you are worried about updating some packages? Conda can load a dedicated environment for you to run Python and Jupyter based on the environment.yml configuration file we provide. Open your favourite shell on the directory you have your project. ( cmd.exe on windows) Run the following commands: This will install and load the Python environment we prepared for iSCAPE conda env create -f environment.yml Now activate the environment source activate iscape Ready, run to run Jupyter jupyter notebook","title":"How to run the project isolated from your Python environment"},{"location":"Sensor Analysis Framework/guides/Install the framework/#advanced-users-installation","text":"If you do not want to install Anaconda you can install all the dependencies manually. Just follow the steps above:","title":"Advanced users installation"},{"location":"Sensor Analysis Framework/guides/Install the framework/#install-python","text":"Python is the main programming language we will use for Data Analysis. On Windows download and run the installer for Python 2.7 Mac cames directly with python built in. However you can install the latest version using Hombrew and then run $ brew install python On Linux simply use your distribution package manager like $ apt in Debian or Ubuntu.","title":"Install Python"},{"location":"Sensor Analysis Framework/guides/Install the framework/#install-pip","text":"Pip is the packet manager Python uses and it comes installed by default. If you have any issues you can download pip here .","title":"Install Pip"},{"location":"Sensor Analysis Framework/guides/Install the framework/#installl-jupyter","text":"Jupyter Notebooks allows us to quickly learn, develop and improve our tools by providing a common convenient framework and UI. Simply run pip install jupyter on your terminal to install it.","title":"Installl Jupyter"},{"location":"Sensor Analysis Framework/guides/Install the framework/#download-the-source","text":"Download from Github or simply use git git clone https://github.com/fablabbcn/smartcitizen-iscape-data.git","title":"Download the source"},{"location":"Sensor Analysis Framework/guides/Install the framework/#run-the-notebook","text":"On your terminal go to the folder where tou downloaded your files and then run jupyter notebook this will open a new webpage and you will be available to run your code there.","title":"Run the notebook"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/","text":"Post processing the Stations Data Link The stations data can be fully processed within the sensor analysis framework provided. In this guide, we will go through a working live example that will use available data from a permanent living lab station in Fablab BCN . The available sensors are listed here . Load in the data Link So first, we will load in the data from this station. The device number is the 4748 , and is available in here . We will use the available interface in our framework to load the station data. In this case, we will load all the available data into our notebook, but if we wanted, we could use the interface to set up time limits, should the timeframe desired be different: Info In the field Kit list we can also input a comma separated list of devices such as: 4748, 4565, 4587 and we will load all the data for you. We can now explore the available readings in our test with something like: ## This will output the devices we have in the selected test print readings [ STATION_FABLAB_BCN ][ devices ] . keys () Output : [u 4748 ] If we want to have access to the actual data, we can go under: ## This will output the dataframe s first 4 lines print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ data ] . head ( 4 ) Output : BATT CO_MICS_RAW EXT_HUM EXT_TEMP GB_1A \\ 2018-08-24 17:00:00+02:00 0.0 73.441111 47.652222 30.663333 4.517778 2018-08-24 17:10:00+02:00 0.0 129.049000 46.632000 31.209000 3.905000 2018-08-24 17:20:00+02:00 0.0 53.738333 45.901667 31.616667 3.808333 2018-08-24 17:30:00+02:00 74.5 122.405000 45.655000 31.810000 3.925000 ... Or if we want to see the available recordings: ## This will output the dataframe columns print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ data ] . columns Output : Index([u BATT , u CO_MICS_RAW , u EXT_HUM , u EXT_TEMP , u GB_1A , u GB_1W , u GB_2A , u GB_2W , u GB_3A , u GB_3W , u HUM , u LIGHT , u NO2_MICS_RAW , u PM_1 , u PM_10 , u PM_25 , u PM_DALLAS_TEMP , u PRESS , u TEMP ], dtype= object ) For more information about the test structure , all the fields are detailed in here . If the device is an station, we will have to input the sensor references for the alphasense devices. We have prepared the framework to input this easily: ## This will output the structure for inputing the alphasense sensor refs print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ] Output : { O3 : TEMPORARY_O3 , SLOTS : TEMPORARY_SLOTS , CO : TEMPORARY_CO , NO2 : TEMPORARY_NO2 } As you can see, we have no data in this struct, but we can easily fill it put by: readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ O3 ] = 204560316 readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ NO2 ] = 202160413 readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ CO ] = 162031257 readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ SLOTS ] = ( NO2 , CO , O3 ) print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ] Output : { O3 : 204560316, SLOTS : ( NO2 , CO , O3 ), CO : 162031257, NO2 : 202160413} Note that each of these fields is necessary for our posterior calculations. Each of the O3 , NO~2~ , CO fields relate to the manufacturer's reference of each of the sensors, whilst the SLOTS field relates to the order at which the sensors are placed. Normally , the stations are delivered with the SLOTS field as: ( CO , NO~2~ , O3 ) , meaning that the CO sensor is in the slot #1, the NO 2 sensor in the slot #2 and the O3 sensor in the slot #3. Info Normally we refer to the OX-B431 sensor as O3, although it measures both, O3+NO 2 mixing ratios, and therefore we use O3 or OX indistinctively. Warning You might have noticed that the slots we have input are not matching to our own description... Our bad! Explore the data Link We can now have a look at the station's data. We can go to the Section Exploratory Data Analysis and use the range of available interfaces for the data analysis. We would like to serve this as a flexible tool, in which the priority is to generate proper analysis. For this, we have some interesting interactive plots as: Time Series Plot Back2Back correlation plots Correlogram Heat maps Let's run a simple example. We will plot all the concerned alphasense signals using the interface. We could also do this by code, but we find it less time consuming and more data analysis dedicated: We can select within the channels available in the dataframe, for each of the devices within a test. All the devices are supossed to have overlapping timestamps, so they can be compared easily. Hence, here is where the concept of test is interesting, since all the devices within a test can be easily grouped and compared: In this example we have selected all three alphasense sensors available data and plotted them with the working and auxiliary electrodes. We can here explore with the plotly integrated commands to review the data. Here, it is important to see how the sensors adapt to the environment once they have their power restored after a power cut, or after the first use. For example, in the case of the CO measurement, after the power restorage on 31 st of August, the sensor is clearly experiencing an stabilisation that has to be discarded in our calculations: We can also see how some metrics correlate among themselves and analyse potential sources for multicollinearity in our model. For this, we will study how every two measurments correlate among themselves in the following interface: We will use a very straightforward example: let's see how temperature and relative humidity correlate and see if there might be variations in the absolute humidity that might affect the variations in the relative humidity that are not explained by the temperature. If we select our channels and Check on Crop Data in X axis and input our dates we will have the following: Here, we can see that both are anticorrelated (Pearson = -0.61) and although they have a clear inverse trend, their R2 is low: This might indicate that the variations in the humidity are not fully explained by the temperature variations and, that there might be variations in the absolute humidity that we could account for in our models. Adding calculated channels Link Let's then add the partial vapour pressure in our dataset. Based on the definition of the relative humidity (RH): RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} Where P_{H_2O} P_{H_2O} is the partial vapour pressure and P^*_{H_2O} P^*_{H_2O} is the equilibrium vapour pressure at a certain pressure and temperature. This equilibrium vapour pressure can be determined by the Arden Buck Equation and goes like: P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} Where P P is the absolute pressure in mbar and T T is the temperature in degC. Having the partial vapour pressure, we can then calculate both values in the implemented calculator in our notebook: Here, the formula is: ## Calculate equilibrium vapour pressure P_H2O_EQ = ( 1.0007 + 3.46 * 1e-6 * PRESS * 10 ) * 6.1121 * np . exp ( 17.502 * TEMP / ( 240.97 + TEMP )) Note that we can input any type of expression in the Formula Field that can be subject to evaluation as in a Python formula. Note as well that numpy operations are allowed and that they can be written in line. Info If you want to calculate this formula for several devices within a test, select all of them and the calculator will make the available in the dropdowns the common metrics. Now, we can calculate de partial vapour pressure as, since it's available within our channels: ## Calculate partial vapour pressure P_H2O_VAP = HUM * P_H2O_EQ / 100 We can now verify that the partial pressure is not constant and plotting it with the other channels: If we analyse the data in periods where the partial vapour pressure is fairly constant (i.e. 31 st of Aug, we see that variations of the temperature are directly correlated with the relative humidity, whilst days as the 2 nd of September show greater variations in both, temperature and partial vapour pressure that provoke a lower correlation in the temperature and humidity: Calculating the actual pollutant concentrations Link Now that we know how to get around in the notebook, explore data and add channels in a simple way, lets calculate actual pollutant concentrations. For this, we will use the section AlphaSense Baseline Calibration . In this block, we will apply the methodology exlained in this section in order to calculate actual pollutant concentrations. For this, in the above mentioned section, if we run the cell, we will see an output like the following: This will list all the available devices that contain alphasense data. Remember to include the calibration data mentioned before in the dict so that we can calculate the final concentrations. For reference, all the alphasense data is under this repository , which looks like: { Target 2 : na , Target 1 : CO , Serial No : 162031254 , Sensitivity 1 : 568.3 , Sensitivity 2 : 0 , Zero Current : -34 , Aux Zero Current : -20.8 } { Target 2 : na , Target 1 : CO , Serial No : 162031257 , Sensitivity 1 : 493.1 , Sensitivity 2 : 0 , Zero Current : -69.4 , Aux Zero Current : -18.6 } { Target 2 : na , Target 1 : CO , Serial No : 162031256 , Sensitivity 1 : 601.9 , Sensitivity 2 : 0 , Zero Current : -68.1 , Aux Zero Current : -13.9 } { Target 2 : na , Target 1 : CO , Serial No : 162581706 , Sensitivity 1 : 581.4 , Sensitivity 2 : 0 , Zero Current : -72.8 , Aux Zero Current : -35.3 } { Target 2 : na , Target 1 : CO , Serial No : 162581707 , Sensitivity 1 : 605 , Sensitivity 2 : 0 , Zero Current : -56.7 , Aux Zero Current : -46.3 } In the cell output, we can select the tests that contain alphasense devices and that are subject to be calculated. A brief explanation of all the checkboxes is detailed below: Decomp : attemps to decompose the trends found in the day-to-day data. This is a common technique used in time series analysis in order to avoid regression including trend. It is normally not needed since the periods that are used for the data calculacions are short enough to have no significant trend (one day + overlap*) Plots Inter : checking this plots intermediary plots of all the calculations performed within the method. Use with caution Verbose : checking this includes extra information during the calculation process. Use with caution Plots Results : plots the final calculation per pollutant and all relevant intermediary calculation. Default is to be Checked Print Stats : prints interesting statistics about the dataset for later use Now, let's calculate the pollutants. We don't need to worry about the manufacturer data, since it will automatically retrieved during the process. CO results The methodology used here is not the baseline model, but the application of this formula, as explained in here : Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} As we can see, the initial data is not to be considered due to the sensor stabilisation time. If we focus on the usable data, we can already get some insights about what hours are more polluted and the difference between working days and weekends: NO 2 results For this metric, we will be using the above mentioned baseline methodology If we have a look at the data, we see that the sensor still requires stabilisation, as the CO electrode: Zooming in, we can see the most polluted hours are those in the morning: Warning OX sensor in this station is not giving good results (probably it's ageing has provoked a sensitivity loss), and therefore, the data will not be shown here.","title":"Post processing the Stations Data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#post-processing-the-stations-data","text":"The stations data can be fully processed within the sensor analysis framework provided. In this guide, we will go through a working live example that will use available data from a permanent living lab station in Fablab BCN . The available sensors are listed here .","title":"Post processing the Stations Data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#load-in-the-data","text":"So first, we will load in the data from this station. The device number is the 4748 , and is available in here . We will use the available interface in our framework to load the station data. In this case, we will load all the available data into our notebook, but if we wanted, we could use the interface to set up time limits, should the timeframe desired be different: Info In the field Kit list we can also input a comma separated list of devices such as: 4748, 4565, 4587 and we will load all the data for you. We can now explore the available readings in our test with something like: ## This will output the devices we have in the selected test print readings [ STATION_FABLAB_BCN ][ devices ] . keys () Output : [u 4748 ] If we want to have access to the actual data, we can go under: ## This will output the dataframe s first 4 lines print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ data ] . head ( 4 ) Output : BATT CO_MICS_RAW EXT_HUM EXT_TEMP GB_1A \\ 2018-08-24 17:00:00+02:00 0.0 73.441111 47.652222 30.663333 4.517778 2018-08-24 17:10:00+02:00 0.0 129.049000 46.632000 31.209000 3.905000 2018-08-24 17:20:00+02:00 0.0 53.738333 45.901667 31.616667 3.808333 2018-08-24 17:30:00+02:00 74.5 122.405000 45.655000 31.810000 3.925000 ... Or if we want to see the available recordings: ## This will output the dataframe columns print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ data ] . columns Output : Index([u BATT , u CO_MICS_RAW , u EXT_HUM , u EXT_TEMP , u GB_1A , u GB_1W , u GB_2A , u GB_2W , u GB_3A , u GB_3W , u HUM , u LIGHT , u NO2_MICS_RAW , u PM_1 , u PM_10 , u PM_25 , u PM_DALLAS_TEMP , u PRESS , u TEMP ], dtype= object ) For more information about the test structure , all the fields are detailed in here . If the device is an station, we will have to input the sensor references for the alphasense devices. We have prepared the framework to input this easily: ## This will output the structure for inputing the alphasense sensor refs print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ] Output : { O3 : TEMPORARY_O3 , SLOTS : TEMPORARY_SLOTS , CO : TEMPORARY_CO , NO2 : TEMPORARY_NO2 } As you can see, we have no data in this struct, but we can easily fill it put by: readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ O3 ] = 204560316 readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ NO2 ] = 202160413 readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ CO ] = 162031257 readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ][ SLOTS ] = ( NO2 , CO , O3 ) print readings [ STATION_FABLAB_BCN ][ devices ][ 4748 ][ alphasense ] Output : { O3 : 204560316, SLOTS : ( NO2 , CO , O3 ), CO : 162031257, NO2 : 202160413} Note that each of these fields is necessary for our posterior calculations. Each of the O3 , NO~2~ , CO fields relate to the manufacturer's reference of each of the sensors, whilst the SLOTS field relates to the order at which the sensors are placed. Normally , the stations are delivered with the SLOTS field as: ( CO , NO~2~ , O3 ) , meaning that the CO sensor is in the slot #1, the NO 2 sensor in the slot #2 and the O3 sensor in the slot #3. Info Normally we refer to the OX-B431 sensor as O3, although it measures both, O3+NO 2 mixing ratios, and therefore we use O3 or OX indistinctively. Warning You might have noticed that the slots we have input are not matching to our own description... Our bad!","title":"Load in the data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#explore-the-data","text":"We can now have a look at the station's data. We can go to the Section Exploratory Data Analysis and use the range of available interfaces for the data analysis. We would like to serve this as a flexible tool, in which the priority is to generate proper analysis. For this, we have some interesting interactive plots as: Time Series Plot Back2Back correlation plots Correlogram Heat maps Let's run a simple example. We will plot all the concerned alphasense signals using the interface. We could also do this by code, but we find it less time consuming and more data analysis dedicated: We can select within the channels available in the dataframe, for each of the devices within a test. All the devices are supossed to have overlapping timestamps, so they can be compared easily. Hence, here is where the concept of test is interesting, since all the devices within a test can be easily grouped and compared: In this example we have selected all three alphasense sensors available data and plotted them with the working and auxiliary electrodes. We can here explore with the plotly integrated commands to review the data. Here, it is important to see how the sensors adapt to the environment once they have their power restored after a power cut, or after the first use. For example, in the case of the CO measurement, after the power restorage on 31 st of August, the sensor is clearly experiencing an stabilisation that has to be discarded in our calculations: We can also see how some metrics correlate among themselves and analyse potential sources for multicollinearity in our model. For this, we will study how every two measurments correlate among themselves in the following interface: We will use a very straightforward example: let's see how temperature and relative humidity correlate and see if there might be variations in the absolute humidity that might affect the variations in the relative humidity that are not explained by the temperature. If we select our channels and Check on Crop Data in X axis and input our dates we will have the following: Here, we can see that both are anticorrelated (Pearson = -0.61) and although they have a clear inverse trend, their R2 is low: This might indicate that the variations in the humidity are not fully explained by the temperature variations and, that there might be variations in the absolute humidity that we could account for in our models.","title":"Explore the data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#adding-calculated-channels","text":"Let's then add the partial vapour pressure in our dataset. Based on the definition of the relative humidity (RH): RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} Where P_{H_2O} P_{H_2O} is the partial vapour pressure and P^*_{H_2O} P^*_{H_2O} is the equilibrium vapour pressure at a certain pressure and temperature. This equilibrium vapour pressure can be determined by the Arden Buck Equation and goes like: P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} Where P P is the absolute pressure in mbar and T T is the temperature in degC. Having the partial vapour pressure, we can then calculate both values in the implemented calculator in our notebook: Here, the formula is: ## Calculate equilibrium vapour pressure P_H2O_EQ = ( 1.0007 + 3.46 * 1e-6 * PRESS * 10 ) * 6.1121 * np . exp ( 17.502 * TEMP / ( 240.97 + TEMP )) Note that we can input any type of expression in the Formula Field that can be subject to evaluation as in a Python formula. Note as well that numpy operations are allowed and that they can be written in line. Info If you want to calculate this formula for several devices within a test, select all of them and the calculator will make the available in the dropdowns the common metrics. Now, we can calculate de partial vapour pressure as, since it's available within our channels: ## Calculate partial vapour pressure P_H2O_VAP = HUM * P_H2O_EQ / 100 We can now verify that the partial pressure is not constant and plotting it with the other channels: If we analyse the data in periods where the partial vapour pressure is fairly constant (i.e. 31 st of Aug, we see that variations of the temperature are directly correlated with the relative humidity, whilst days as the 2 nd of September show greater variations in both, temperature and partial vapour pressure that provoke a lower correlation in the temperature and humidity:","title":"Adding calculated channels"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#calculating-the-actual-pollutant-concentrations","text":"Now that we know how to get around in the notebook, explore data and add channels in a simple way, lets calculate actual pollutant concentrations. For this, we will use the section AlphaSense Baseline Calibration . In this block, we will apply the methodology exlained in this section in order to calculate actual pollutant concentrations. For this, in the above mentioned section, if we run the cell, we will see an output like the following: This will list all the available devices that contain alphasense data. Remember to include the calibration data mentioned before in the dict so that we can calculate the final concentrations. For reference, all the alphasense data is under this repository , which looks like: { Target 2 : na , Target 1 : CO , Serial No : 162031254 , Sensitivity 1 : 568.3 , Sensitivity 2 : 0 , Zero Current : -34 , Aux Zero Current : -20.8 } { Target 2 : na , Target 1 : CO , Serial No : 162031257 , Sensitivity 1 : 493.1 , Sensitivity 2 : 0 , Zero Current : -69.4 , Aux Zero Current : -18.6 } { Target 2 : na , Target 1 : CO , Serial No : 162031256 , Sensitivity 1 : 601.9 , Sensitivity 2 : 0 , Zero Current : -68.1 , Aux Zero Current : -13.9 } { Target 2 : na , Target 1 : CO , Serial No : 162581706 , Sensitivity 1 : 581.4 , Sensitivity 2 : 0 , Zero Current : -72.8 , Aux Zero Current : -35.3 } { Target 2 : na , Target 1 : CO , Serial No : 162581707 , Sensitivity 1 : 605 , Sensitivity 2 : 0 , Zero Current : -56.7 , Aux Zero Current : -46.3 } In the cell output, we can select the tests that contain alphasense devices and that are subject to be calculated. A brief explanation of all the checkboxes is detailed below: Decomp : attemps to decompose the trends found in the day-to-day data. This is a common technique used in time series analysis in order to avoid regression including trend. It is normally not needed since the periods that are used for the data calculacions are short enough to have no significant trend (one day + overlap*) Plots Inter : checking this plots intermediary plots of all the calculations performed within the method. Use with caution Verbose : checking this includes extra information during the calculation process. Use with caution Plots Results : plots the final calculation per pollutant and all relevant intermediary calculation. Default is to be Checked Print Stats : prints interesting statistics about the dataset for later use Now, let's calculate the pollutants. We don't need to worry about the manufacturer data, since it will automatically retrieved during the process. CO results The methodology used here is not the baseline model, but the application of this formula, as explained in here : Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} As we can see, the initial data is not to be considered due to the sensor stabilisation time. If we focus on the usable data, we can already get some insights about what hours are more polluted and the difference between working days and weekends: NO 2 results For this metric, we will be using the above mentioned baseline methodology If we have a look at the data, we see that the sensor still requires stabilisation, as the CO electrode: Zooming in, we can see the most polluted hours are those in the morning: Warning OX sensor in this station is not giving good results (probably it's ageing has provoked a sensitivity loss), and therefore, the data will not be shown here.","title":"Calculating the actual pollutant concentrations"},{"location":"Sensor Platform/","text":"Sensor Platform Link The Smart Citizen platform supports the core features of the platform. That means this report documents new components, developed specifically for the project, but also existing components that already existed and made possible the platform. We believe building modular and reusable software and using existing platforms is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. The previous requirements led to the decision of building the core platform on top of the existing Smart Citizen Platform. The platform is a front and backend solution for ingesting, storing and interacting with public data with a particular focus on crowd sensing applications. The platform is the software solution behind the Smart Citizen project as the result of the knowledge acquired after five years of running the Smart Citizen project at IAAC. That means sensor data on ISCAPE is managed by a robust and mature framework but even more important it stay on the platform designed to remain long after the project is over. Check the guides We prepared a series of guides to help you on the most common features you will use Onboarding Sensors Uploading CSV Data Want to learn more? Check the developers ready API Documentation Software components Link Smart Citizen Website: The platform provides a visual website where the project environmental sensors can be accessed in near real time to facilitate the exploration of data with other contextual data (maps, keywords) and processed reports. This is especially important towards citizens engaging at each local site having a sense of ownership over a technology intervention has been associated with sustained community engagement (Balestrini et al. 2014) . Smart Citizen API: The platform provides a REST interface for all the functionalities available on the Website. That allows applications to be developed on easily on top having access to all the features to create complex and rich tools. Some examples of this tools are: Smart Citizen Android App, ISCAPE Data Analysis Framework and the ISCAPE Virtual Living Lab. Virtual Living Lab: It is currently being built as part of T8.1 and will provide an online web platform where each Living Lab can share their advances and contact with their local communities. The tools will feature different modules allowing the data from the sensors deployed by a Living Lab to be visualized on the site. It retrieves the data using the Smart Citizen API. Onboarding app: It aim to facilitate the process of sensor setup to ensure that users, irrespective of technical expertise, can install the sensors. It guides the user through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. It exchange data with the core platform using the Smart Citizen API. Archiving for long term preservation: All the sensor data collected during the project will be later on submitted to the Zenodo platform for long term archiving and digital reference. As a European Commission supported initiative and technically supported by CERN, we believe this is the best way to ensure access to the generated data remains long after the project ends. Source files Link Check the source code","title":"Index"},{"location":"Sensor Platform/#sensor-platform","text":"The Smart Citizen platform supports the core features of the platform. That means this report documents new components, developed specifically for the project, but also existing components that already existed and made possible the platform. We believe building modular and reusable software and using existing platforms is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. The previous requirements led to the decision of building the core platform on top of the existing Smart Citizen Platform. The platform is a front and backend solution for ingesting, storing and interacting with public data with a particular focus on crowd sensing applications. The platform is the software solution behind the Smart Citizen project as the result of the knowledge acquired after five years of running the Smart Citizen project at IAAC. That means sensor data on ISCAPE is managed by a robust and mature framework but even more important it stay on the platform designed to remain long after the project is over. Check the guides We prepared a series of guides to help you on the most common features you will use Onboarding Sensors Uploading CSV Data Want to learn more? Check the developers ready API Documentation","title":"Sensor Platform"},{"location":"Sensor Platform/#software-components","text":"Smart Citizen Website: The platform provides a visual website where the project environmental sensors can be accessed in near real time to facilitate the exploration of data with other contextual data (maps, keywords) and processed reports. This is especially important towards citizens engaging at each local site having a sense of ownership over a technology intervention has been associated with sustained community engagement (Balestrini et al. 2014) . Smart Citizen API: The platform provides a REST interface for all the functionalities available on the Website. That allows applications to be developed on easily on top having access to all the features to create complex and rich tools. Some examples of this tools are: Smart Citizen Android App, ISCAPE Data Analysis Framework and the ISCAPE Virtual Living Lab. Virtual Living Lab: It is currently being built as part of T8.1 and will provide an online web platform where each Living Lab can share their advances and contact with their local communities. The tools will feature different modules allowing the data from the sensors deployed by a Living Lab to be visualized on the site. It retrieves the data using the Smart Citizen API. Onboarding app: It aim to facilitate the process of sensor setup to ensure that users, irrespective of technical expertise, can install the sensors. It guides the user through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. It exchange data with the core platform using the Smart Citizen API. Archiving for long term preservation: All the sensor data collected during the project will be later on submitted to the Zenodo platform for long term archiving and digital reference. As a European Commission supported initiative and technically supported by CERN, we believe this is the best way to ensure access to the generated data remains long after the project ends.","title":"Software components"},{"location":"Sensor Platform/#source-files","text":"Check the source code","title":"Source files"},{"location":"Sensor Platform/guides/Downloading the Data/","text":"Downloading the Data Link Introduction Link Here some instructions on how to upload CSV files to Smartcitizen platform. First be sure to be logged and go to your profile . Step by step On your kits' list, click on the wheel and then on \"Upload CSV\". Once on the upload page, you can add some files by clicking on the \"Load CSV files\" button. Select some files as much as you like, to be them ready to upload. Then on the drop-down menu select the \"Upload\" option Click on the \"Apply\" button to upload them Congrats! You just uploaded your files CSV files on the Smartcitizen platform.","title":"Downloading the Data"},{"location":"Sensor Platform/guides/Downloading the Data/#downloading-the-data","text":"","title":"Downloading the Data"},{"location":"Sensor Platform/guides/Downloading the Data/#introduction","text":"Here some instructions on how to upload CSV files to Smartcitizen platform. First be sure to be logged and go to your profile . Step by step On your kits' list, click on the wheel and then on \"Upload CSV\". Once on the upload page, you can add some files by clicking on the \"Load CSV files\" button. Select some files as much as you like, to be them ready to upload. Then on the drop-down menu select the \"Upload\" option Click on the \"Apply\" button to upload them Congrats! You just uploaded your files CSV files on the Smartcitizen platform.","title":"Introduction"},{"location":"Sensor Platform/guides/Onboarding Sensors/","text":"Onboarding Sensors Link The oboarding appp guides you through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. Onboarding app Visit the onboarding app at onboarding.iscape.smartcitizen.me Step by step Welcome page Select all the parts you received to ensure you are not missing any part Turn on your Kit Close the cover of your device Choose the Wi-Fi network you want to connect to You will reiceive a message when the Kit it is connected Add a name to your sensor Select the location for your sensor Add your email to register the Kit under your name Add a user name for people to see you on the platform Add a password to protect your account You are done! Visit the Kit on the platform. Wait one minute till it publishes data Look at the data!","title":"Onboarding Sensors"},{"location":"Sensor Platform/guides/Onboarding Sensors/#onboarding-sensors","text":"The oboarding appp guides you through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. Onboarding app Visit the onboarding app at onboarding.iscape.smartcitizen.me Step by step Welcome page Select all the parts you received to ensure you are not missing any part Turn on your Kit Close the cover of your device Choose the Wi-Fi network you want to connect to You will reiceive a message when the Kit it is connected Add a name to your sensor Select the location for your sensor Add your email to register the Kit under your name Add a user name for people to see you on the platform Add a password to protect your account You are done! Visit the Kit on the platform. Wait one minute till it publishes data Look at the data!","title":"Onboarding Sensors"},{"location":"Sensor Platform/guides/Uploading CSV Data/","text":"Uploading CSV Data Link","title":"Uploading CSV Data"},{"location":"Sensor Platform/guides/Uploading CSV Data/#uploading-csv-data","text":"","title":"Uploading CSV Data"}]}